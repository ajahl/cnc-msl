   1               		.file	"main.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 118               		.section	.rodata.str1.1,"aMS",@progbits,1
 119               	.LC0:
 120 0000 4361 6E6E 		.string	"Cannot register timer\n"
 120      6F74 2072 
 120      6567 6973 
 120      7465 7220 
 120      7469 6D65 
 121               		.section	.text.startup,"ax",@progbits
 123               	.global	main
 125               	main:
   1:main.c        **** // rekick
   2:main.c        **** //
   3:main.c        **** // Firmware for the rekick controlling device.
   4:main.c        **** //
   5:main.c        **** // This device controls the servo for rotating the coil to the three directions
   6:main.c        **** // and loads the capacitors with use of the boosting device.
   7:main.c        **** //
   8:main.c        **** // Author: Kai Buamgart <kb@zkar.de> (c) 2008
   9:main.c        **** //
  10:main.c        **** // TODO Software:
  11:main.c        **** //  * Servo 1 PWM enablen
  12:main.c        **** //  * Servo 2 PWM enablen
  13:main.c        **** //  * Rotation
  14:main.c        **** //  * Schalter Rotor
  15:main.c        **** //  * Timeout CAN-Messages
  16:main.c        **** //  * Erste CAN-Messages annehmen aber verwerfen
  17:main.c        **** //  * CAN-ID behandeln
  18:main.c        **** //  * ReKick deaktiviert sich selbst, wenn innerhalb einer bestimmten Zeit
  19:main.c        **** //  * keine Alive-Message von Kicker.exe angenommen wurde
  20:main.c        **** //  * ReKick kann in einen manuellen oder debug-Modus geschaltet werden, wo
  21:main.c        **** //  * keine Alive-Messages von einer überliegenden Software benötigt wird.
  22:main.c        **** //  * Logging. Man könnte den EEPROM zum loggen benutzen.
  23:main.c        **** //  * Abzuspeichern wäre: Ladezeit nach einem Schuss, Schuss, etc.
  24:main.c        **** //
  25:main.c        **** // TODO Hardware:
  26:main.c        **** //  * P-MOSFET rekick einbauen und testen
  27:main.c        **** //  * Am Booster Leiterbahnen dicker
  28:main.c        **** //  * Gegentakt-Schaltung wurde verändert. Dies im Layout aufnehmen.
  29:main.c        **** 
  30:main.c        **** #include <avr/interrupt.h>
  31:main.c        **** #include <avr/pgmspace.h>
  32:main.c        **** #include <string.h>
  33:main.c        **** #include <stdio.h>
  34:main.c        **** 
  35:main.c        **** #include "defs.h"
  36:main.c        **** #include "messages.h"
  37:main.c        **** #include "timer.h"
  38:main.c        **** #include "booster.h"
  39:main.c        **** #include "kicker.h"
  40:main.c        **** #include "ports.h"
  41:main.c        **** #include "defaults.h"
  42:main.c        **** #include <avr/io.h>
  43:main.c        **** #include "global.h"
  44:main.c        **** #include "ports.h"
  45:main.c        **** 
  46:main.c        **** // prototypes
  47:main.c        **** char *check_hw_reset(unsigned char);
  48:main.c        **** 
  49:main.c        **** int main(void) {
 127               	.LM0:
 128               	.LFBB1:
 129 0000 CF93      		push r28
 130 0002 DF93      		push r29
 131 0004 1F92      		push __zero_reg__
 132 0006 CDB7      		in r28,__SP_L__
 133 0008 DEB7      		in r29,__SP_H__
 134               	/* prologue: function */
 135               	/* frame size = 1 */
 136               	/* stack size = 3 */
 137               	.L__stack_usage = 3
  50:main.c        **** 
  51:main.c        **** 	//disable booster power (power off)
  52:main.c        **** 	SET_OUTPUT(POWER);
 139               	.LM1:
 140 000a D49A      		sbi 0x1a,4
  53:main.c        **** 	RESET(POWER);
 142               	.LM2:
 143 000c DC98      		cbi 0x1b,4
  54:main.c        **** 
  55:main.c        **** 
  56:main.c        **** 	// not-normal-operation-pin high until everything is done
  57:main.c        **** 	DDRA |= (1 << DDA5);
 145               	.LM3:
 146 000e D59A      		sbi 0x1a,5
  58:main.c        **** 	PORTA |= (1 << PA5);
 148               	.LM4:
 149 0010 DD9A      		sbi 0x1b,5
  59:main.c        **** 	
  60:main.c        **** 
  61:main.c        **** 	// save reset-register and reset the value
  62:main.c        **** 	uint8_t reset_msg[1] = {MCUCSR};
 151               	.LM5:
 152 0012 84B7      		in r24,0x34
 153 0014 8983      		std Y+1,r24
  63:main.c        **** 	MCUCSR = 0x00;
 155               	.LM6:
 156 0016 14BE      		out 0x34,__zero_reg__
  64:main.c        **** 
  65:main.c        **** 	// turn off watchdog
  66:main.c        **** 	WDTCR = 0x00;
 158               	.LM7:
 159 0018 11BC      		out 0x21,__zero_reg__
  67:main.c        **** 	
  68:main.c        **** 	// enable interrupts
  69:main.c        **** 	sei();
 161               	.LM8:
 162               	/* #APP */
 163               	 ;  69 "main.c" 1
 164 001a 7894      		sei
 165               	 ;  0 "" 2
  70:main.c        **** 
  71:main.c        **** 	can_init();
 167               	.LM9:
 168               	/* #NOAPP */
 169 001c 0E94 0000 		call can_init
  72:main.c        **** 	ports_init();
 171               	.LM10:
 172 0020 0E94 0000 		call ports_init
  73:main.c        **** 	kicker_init();
 174               	.LM11:
 175 0024 0E94 0000 		call kicker_init
  74:main.c        **** 	timer_init();
 177               	.LM12:
 178 0028 0E94 0000 		call timer_init
  75:main.c        **** 	booster_init();
 180               	.LM13:
 181 002c 0E94 0000 		call booster_init
 182               	.L2:
  76:main.c        **** 
  77:main.c        **** 	// wait until eth2can is up and running or erase can_buffer
  78:main.c        **** 	while (timer_get_ms() < 1500)
 184               	.LM14:
 185 0030 0E94 0000 		call timer_get_ms
 186 0034 6C3D      		cpi r22,-36
 187 0036 7540      		sbci r23,5
 188 0038 8105      		cpc r24,__zero_reg__
 189 003a 9105      		cpc r25,__zero_reg__
 190 003c 00F4      		brsh .L10
  79:main.c        **** 		clear_receive_buffer();
 192               	.LM15:
 193 003e 0E94 0000 		call clear_receive_buffer
 194 0042 00C0      		rjmp .L2
 195               	.L10:
  80:main.c        **** 
  81:main.c        **** 	// send reset message
  82:main.c        **** 	can_put_cmd(CMD_RESET, reset_msg, 1);
 197               	.LM16:
 198 0044 41E0      		ldi r20,lo8(1)
 199 0046 BE01      		movw r22,r28
 200 0048 6F5F      		subi r22,-1
 201 004a 7F4F      		sbci r23,-1
 202 004c 84EF      		ldi r24,lo8(-12)
 203 004e 0E94 0000 		call can_put_cmd
  83:main.c        **** 
  84:main.c        **** 	if (timer_register(toggle_status_led, 500) != EXIT_SUCCESS)
 205               	.LM17:
 206 0052 64EF      		ldi r22,lo8(-12)
 207 0054 71E0      		ldi r23,lo8(1)
 208 0056 80E0      		ldi r24,lo8(gs(toggle_status_led))
 209 0058 90E0      		ldi r25,hi8(gs(toggle_status_led))
 210 005a 0E94 0000 		call timer_register
 211 005e 8823      		tst r24
 212 0060 01F0      		breq .L5
  85:main.c        **** 		error("Cannot register timer\n");
 214               	.LM18:
 215 0062 80E0      		ldi r24,lo8(.LC0)
 216 0064 90E0      		ldi r25,hi8(.LC0)
 217 0066 0E94 0000 		call error
 218               	.L5:
  86:main.c        **** 	//if (timer_register(booster_send_info, 500) != EXIT_SUCCESS)
  87:main.c        **** 	//	error("Cannot register timer\n");
  88:main.c        **** 
  89:main.c        **** 	//can_test();
  90:main.c        **** 	
  91:main.c        **** 	// to initialize we let the rekick rotate the kicker to position #1
  92:main.c        **** 	//kicker_add_rotate_job(1);
  93:main.c        **** 	
  94:main.c        **** 	for (;;) {
  95:main.c        **** 		timer_trigger_callbacks();
 220               	.LM19:
 221 006a 0E94 0000 		call timer_trigger_callbacks
  96:main.c        **** 		message_handler();
 223               	.LM20:
 224 006e 0E94 0000 		call message_handler
  97:main.c        **** 		kicker_task_handler();
 226               	.LM21:
 227 0072 0E94 0000 		call kicker_task_handler
  98:main.c        **** 		booster_ctrl();
 229               	.LM22:
 230 0076 0E94 0000 		call booster_ctrl
  99:main.c        **** 		can_send_handler();
 232               	.LM23:
 233 007a 0E94 0000 		call can_send_handler
 234 007e 00C0      		rjmp .L5
 239               	.Lscope1:
 240               		.text
 243               	.global	check_hw_reset
 245               	check_hw_reset:
 100:main.c        **** 	}
 101:main.c        **** 
 102:main.c        **** 	return 0;
 103:main.c        **** }
 104:main.c        **** 
 105:main.c        **** 
 106:main.c        **** /**
 107:main.c        ****  * Check which reset flag is set
 108:main.c        ****  *
 109:main.c        ****  * @param mcucsr The register which holds the data.
 110:main.c        ****  * @returns      A string with the output.
 111:main.c        ****  */
 112:main.c        **** char *check_hw_reset(unsigned char mcucsr) {
 247               	.LM24:
 248               	.LFBB2:
 249               	/* prologue: function */
 250               	/* frame size = 0 */
 251               	/* stack size = 0 */
 252               	.L__stack_usage = 0
 113:main.c        **** 	if (mcucsr & (1 << PORF))
 254               	.LM25:
 255 0000 80FD      		sbrc r24,0
 256 0002 00C0      		rjmp .L13
 114:main.c        **** 		return PSTR("Power On");
 115:main.c        **** 	else if (mcucsr & (1 << JTRF))
 258               	.LM26:
 259 0004 84FD      		sbrc r24,4
 260 0006 00C0      		rjmp .L14
 116:main.c        **** 		return PSTR("JTAG");
 117:main.c        **** 	else if (mcucsr & (1 << WDRF))
 262               	.LM27:
 263 0008 83FD      		sbrc r24,3
 264 000a 00C0      		rjmp .L15
 118:main.c        **** 		return PSTR("WATCHDOG");
 119:main.c        **** 	else if (mcucsr & (1 << BORF))
 266               	.LM28:
 267 000c 82FD      		sbrc r24,2
 268 000e 00C0      		rjmp .L16
 120:main.c        **** 		return PSTR("BROWN OUT");
 121:main.c        **** 	else if (mcucsr & (1 << EXTRF))
 270               	.LM29:
 271 0010 81FF      		sbrs r24,1
 272 0012 00C0      		rjmp .L17
 122:main.c        **** 		return PSTR("External");
 274               	.LM30:
 275 0014 80E0      		ldi r24,lo8(__c.2052)
 276 0016 90E0      		ldi r25,hi8(__c.2052)
 277 0018 0895      		ret
 278               	.L13:
 114:main.c        **** 		return PSTR("Power On");
 280               	.LM31:
 281 001a 80E0      		ldi r24,lo8(__c.2044)
 282 001c 90E0      		ldi r25,hi8(__c.2044)
 283 001e 0895      		ret
 284               	.L14:
 116:main.c        **** 		return PSTR("JTAG");
 286               	.LM32:
 287 0020 80E0      		ldi r24,lo8(__c.2046)
 288 0022 90E0      		ldi r25,hi8(__c.2046)
 289 0024 0895      		ret
 290               	.L15:
 118:main.c        **** 		return PSTR("WATCHDOG");
 292               	.LM33:
 293 0026 80E0      		ldi r24,lo8(__c.2048)
 294 0028 90E0      		ldi r25,hi8(__c.2048)
 295 002a 0895      		ret
 296               	.L16:
 120:main.c        **** 		return PSTR("BROWN OUT");
 298               	.LM34:
 299 002c 80E0      		ldi r24,lo8(__c.2050)
 300 002e 90E0      		ldi r25,hi8(__c.2050)
 301 0030 0895      		ret
 302               	.L17:
 123:main.c        **** 	else
 124:main.c        **** 		return PSTR("UNDEF");
 304               	.LM35:
 305 0032 80E0      		ldi r24,lo8(__c.2054)
 306 0034 90E0      		ldi r25,hi8(__c.2054)
 125:main.c        **** }
 308               	.LM36:
 309 0036 0895      		ret
 311               	.Lscope2:
 312               		.section	.progmem.data,"a",@progbits
 315               	__c.2054:
 316 0000 554E 4445 		.string	"UNDEF"
 316      4600 
 319               	__c.2052:
 320 0006 4578 7465 		.string	"External"
 320      726E 616C 
 320      00
 323               	__c.2050:
 324 000f 4252 4F57 		.string	"BROWN OUT"
 324      4E20 4F55 
 324      5400 
 327               	__c.2048:
 328 0019 5741 5443 		.string	"WATCHDOG"
 328      4844 4F47 
 328      00
 331               	__c.2046:
 332 0022 4A54 4147 		.string	"JTAG"
 332      00
 335               	__c.2044:
 336 0027 506F 7765 		.string	"Power On"
 336      7220 4F6E 
 336      00
 337               		.text
 339               	.Letext0:
 340               		.ident	"GCC: (GNU) 4.8.2"
 341               	.global __do_copy_data
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/ccj38pdB.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccj38pdB.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccj38pdB.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccj38pdB.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccj38pdB.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccj38pdB.s:125    .text.startup:0000000000000000 main
     /tmp/ccj38pdB.s:245    .text:0000000000000000 check_hw_reset
     /tmp/ccj38pdB.s:319    .progmem.data:0000000000000006 __c.2052
     /tmp/ccj38pdB.s:335    .progmem.data:0000000000000027 __c.2044
     /tmp/ccj38pdB.s:331    .progmem.data:0000000000000022 __c.2046
     /tmp/ccj38pdB.s:327    .progmem.data:0000000000000019 __c.2048
     /tmp/ccj38pdB.s:323    .progmem.data:000000000000000f __c.2050
     /tmp/ccj38pdB.s:315    .progmem.data:0000000000000000 __c.2054

UNDEFINED SYMBOLS
can_init
ports_init
kicker_init
timer_init
booster_init
timer_get_ms
clear_receive_buffer
can_put_cmd
toggle_status_led
timer_register
error
timer_trigger_callbacks
message_handler
kicker_task_handler
booster_ctrl
can_send_handler
__do_copy_data
