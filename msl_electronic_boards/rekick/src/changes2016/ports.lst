   1               		.file	"ports.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 102               	.global	toggle_status_led
 104               	toggle_status_led:
   1:ports.c       **** #include <avr/io.h>
   2:ports.c       **** 
   3:ports.c       **** // use AVCC as reference
   4:ports.c       **** #define ADCREF  (1 << REFS0)
   5:ports.c       **** 
   6:ports.c       **** void toggle_status_led(void) {
 106               	.LM0:
 107               	.LFBB1:
 108               	/* prologue: function */
 109               	/* frame size = 0 */
 110               	/* stack size = 0 */
 111               	.L__stack_usage = 0
   7:ports.c       **** 	
   8:ports.c       **** 	PORTD ^= (1 << PD6);
 113               	.LM1:
 114 0000 82B3      		in r24,0x12
 115 0002 90E4      		ldi r25,lo8(64)
 116 0004 8927      		eor r24,r25
 117 0006 82BB      		out 0x12,r24
 118 0008 0895      		ret
 120               	.Lscope1:
 122               	.global	read_adc
 124               	read_adc:
   9:ports.c       **** }
  10:ports.c       **** 
  11:ports.c       **** uint16_t read_adc(void) {
 126               	.LM2:
 127               	.LFBB2:
 128               	/* prologue: function */
 129               	/* frame size = 0 */
 130               	/* stack size = 0 */
 131               	.L__stack_usage = 0
 132               	.L4:
  12:ports.c       **** 
  13:ports.c       **** 	uint8_t i;
  14:ports.c       **** 	uint16_t res = 0;
  15:ports.c       **** 
  16:ports.c       **** 	// wait for end of last (test-) conversion
  17:ports.c       **** 	while (ADCSRA & (1 << ADSC));
 134               	.LM3:
 135 000a 3699      		sbic 0x6,6
 136 000c 00C0      		rjmp .L4
 138               	.LM4:
 139 000e 43E0      		ldi r20,lo8(3)
 140 0010 80E0      		ldi r24,0
 141 0012 90E0      		ldi r25,0
 142               	.L8:
  18:ports.c       **** 
  19:ports.c       **** 	// read channel
  20:ports.c       **** 	for (i = 0; i < 3; i++) {
  21:ports.c       **** 		ADCSRA |= (1 << ADSC);
 144               	.LM5:
 145 0014 369A      		sbi 0x6,6
 146               	.L6:
  22:ports.c       **** 		while (ADCSRA & (1 << ADSC));
 148               	.LM6:
 149 0016 3699      		sbic 0x6,6
 150 0018 00C0      		rjmp .L6
  23:ports.c       **** 		res += ADCW;
 152               	.LM7:
 153 001a 24B1      		in r18,0x4
 154 001c 35B1      		in r19,0x4+1
 155 001e 820F      		add r24,r18
 156 0020 931F      		adc r25,r19
 157 0022 4150      		subi r20,lo8(-(-1))
  20:ports.c       **** 	for (i = 0; i < 3; i++) {
 159               	.LM8:
 160 0024 01F4      		brne .L8
  24:ports.c       **** 	}
  25:ports.c       **** 	res /= 3;
 162               	.LM9:
 163 0026 63E0      		ldi r22,lo8(3)
 164 0028 70E0      		ldi r23,0
 165 002a 0E94 0000 		call __udivmodhi4
 166 002e CB01      		movw r24,r22
  26:ports.c       **** 
  27:ports.c       **** 	return res;
  28:ports.c       **** }
 168               	.LM10:
 169 0030 0895      		ret
 171               	.Lscope2:
 174               	.global	select_adc_channel
 176               	select_adc_channel:
  29:ports.c       **** 
  30:ports.c       **** void select_adc_channel(uint8_t mux) {
 178               	.LM11:
 179               	.LFBB3:
 180               	/* prologue: function */
 181               	/* frame size = 0 */
 182               	/* stack size = 0 */
 183               	.L__stack_usage = 0
  31:ports.c       **** 
  32:ports.c       **** 	uint8_t last_channel, new_channel;
  33:ports.c       **** 
  34:ports.c       **** 	last_channel = ADMUX;
 185               	.LM12:
 186 0032 97B1      		in r25,0x7
  35:ports.c       **** 	new_channel = ADCREF | mux;
 188               	.LM13:
 189 0034 8064      		ori r24,lo8(64)
  36:ports.c       **** 
  37:ports.c       **** 	// change channel
  38:ports.c       **** 	if (last_channel != new_channel) {
 191               	.LM14:
 192 0036 9817      		cp r25,r24
 193 0038 01F0      		breq .L10
  39:ports.c       **** 		ADMUX = new_channel;
 195               	.LM15:
 196 003a 87B9      		out 0x7,r24
  40:ports.c       **** 		// start a test-conversion, but do not wait
  41:ports.c       **** 		ADCSRA |= (1 << ADSC);
 198               	.LM16:
 199 003c 369A      		sbi 0x6,6
 200               	.L10:
 201 003e 0895      		ret
 207               	.Lscope3:
 209               	.global	ports_init
 211               	ports_init:
  42:ports.c       **** 	}
  43:ports.c       **** 
  44:ports.c       **** 	return;
  45:ports.c       **** }
  46:ports.c       **** 
  47:ports.c       **** void ports_init(void) {
 213               	.LM17:
 214               	.LFBB4:
 215               	/* prologue: function */
 216               	/* frame size = 0 */
 217               	/* stack size = 0 */
 218               	.L__stack_usage = 0
  48:ports.c       **** 
  49:ports.c       **** 	// select adc multiplexer channel
  50:ports.c       **** 	ADCSRA = (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
 220               	.LM18:
 221 0040 87E8      		ldi r24,lo8(-121)
 222 0042 86B9      		out 0x6,r24
  51:ports.c       **** 	ADMUX = ADCREF;
 224               	.LM19:
 225 0044 80E4      		ldi r24,lo8(64)
 226 0046 87B9      		out 0x7,r24
  52:ports.c       **** 	select_adc_channel(6);
 228               	.LM20:
 229 0048 86E0      		ldi r24,lo8(6)
 230 004a 0E94 0000 		call select_adc_channel
  53:ports.c       **** 
  54:ports.c       **** 	// Set green status led on 
  55:ports.c       **** 	DDRD |= (1 << DDD6); 
 232               	.LM21:
 233 004e 8E9A      		sbi 0x11,6
 234 0050 0895      		ret
 236               	.Lscope4:
 237               	.global	__floatunsisf
 238               	.global	__mulsf3
 239               	.global	__fixunssfsi
 241               	.global	get_capacitors_voltage
 243               	get_capacitors_voltage:
  56:ports.c       **** 
  57:ports.c       **** }
  58:ports.c       **** 
  59:ports.c       **** uint16_t get_capacitors_voltage(void) {
 245               	.LM22:
 246               	.LFBB5:
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 0 */
 250               	.L__stack_usage = 0
  60:ports.c       **** 	
  61:ports.c       **** 	select_adc_channel(6);
 252               	.LM23:
 253 0052 86E0      		ldi r24,lo8(6)
 254 0054 0E94 0000 		call select_adc_channel
  62:ports.c       **** 	uint16_t ret = read_adc();
 256               	.LM24:
 257 0058 0E94 0000 		call read_adc
  63:ports.c       **** 
  64:ports.c       **** 	return ret * 0.2906;
 259               	.LM25:
 260 005c BC01      		movw r22,r24
 261 005e 80E0      		ldi r24,0
 262 0060 90E0      		ldi r25,0
 263 0062 0E94 0000 		call __floatunsisf
 264 0066 26E8      		ldi r18,lo8(-122)
 265 0068 39EC      		ldi r19,lo8(-55)
 266 006a 44E9      		ldi r20,lo8(-108)
 267 006c 5EE3      		ldi r21,lo8(62)
 268 006e 0E94 0000 		call __mulsf3
 269 0072 0E94 0000 		call __fixunssfsi
  65:ports.c       **** }
 271               	.LM26:
 272 0076 CB01      		movw r24,r22
 273 0078 0895      		ret
 278               	.Lscope5:
 280               	.global	get_supply_voltage
 282               	get_supply_voltage:
  66:ports.c       **** 
  67:ports.c       **** float get_supply_voltage(void) {
 284               	.LM27:
 285               	.LFBB6:
 286               	/* prologue: function */
 287               	/* frame size = 0 */
 288               	/* stack size = 0 */
 289               	.L__stack_usage = 0
  68:ports.c       **** 	
  69:ports.c       **** 	select_adc_channel(1);
 291               	.LM28:
 292 007a 81E0      		ldi r24,lo8(1)
 293 007c 0E94 0000 		call select_adc_channel
  70:ports.c       **** 	uint16_t ret = read_adc();
 295               	.LM29:
 296 0080 0E94 0000 		call read_adc
  71:ports.c       **** 
  72:ports.c       **** 	return ret * 0.0394629;
 298               	.LM30:
 299 0084 BC01      		movw r22,r24
 300 0086 80E0      		ldi r24,0
 301 0088 90E0      		ldi r25,0
 302 008a 0E94 0000 		call __floatunsisf
 303 008e 2AED      		ldi r18,lo8(-38)
 304 0090 33EA      		ldi r19,lo8(-93)
 305 0092 41E2      		ldi r20,lo8(33)
 306 0094 5DE3      		ldi r21,lo8(61)
 307 0096 0E94 0000 		call __mulsf3
  73:ports.c       **** }
 309               	.LM31:
 310 009a 0895      		ret
 315               	.Lscope6:
 317               	.global	get_supply_raw_voltage
 319               	get_supply_raw_voltage:
  74:ports.c       **** 
  75:ports.c       **** uint16_t get_supply_raw_voltage(void) {
 321               	.LM32:
 322               	.LFBB7:
 323               	/* prologue: function */
 324               	/* frame size = 0 */
 325               	/* stack size = 0 */
 326               	.L__stack_usage = 0
  76:ports.c       **** 	
  77:ports.c       **** 	select_adc_channel(1);
 328               	.LM33:
 329 009c 81E0      		ldi r24,lo8(1)
 330 009e 0E94 0000 		call select_adc_channel
  78:ports.c       **** 	uint16_t ret = read_adc();
 332               	.LM34:
 333 00a2 0C94 0000 		jmp read_adc
 335               	.Lscope7:
 337               	.Letext0:
 338               		.ident	"GCC: (GNU) 4.8.2"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 ports.c
     /tmp/ccvnMFL9.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccvnMFL9.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccvnMFL9.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccvnMFL9.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccvnMFL9.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccvnMFL9.s:104    .text:0000000000000000 toggle_status_led
     /tmp/ccvnMFL9.s:124    .text:000000000000000a read_adc
     /tmp/ccvnMFL9.s:176    .text:0000000000000032 select_adc_channel
     /tmp/ccvnMFL9.s:211    .text:0000000000000040 ports_init
     /tmp/ccvnMFL9.s:243    .text:0000000000000052 get_capacitors_voltage
     /tmp/ccvnMFL9.s:282    .text:000000000000007a get_supply_voltage
     /tmp/ccvnMFL9.s:319    .text:000000000000009c get_supply_raw_voltage

UNDEFINED SYMBOLS
__udivmodhi4
__floatunsisf
__mulsf3
__fixunssfsi
