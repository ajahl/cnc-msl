   1               		.file	"timer.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   8               		.text
   9               	.Ltext0:
 106               	.global	__vector_11
 108               	__vector_11:
   1:timer.c       **** #include <avr/interrupt.h>
   2:timer.c       **** #include <avr/io.h>
   3:timer.c       **** 
   4:timer.c       **** #include "defs.h"
   5:timer.c       **** 
   6:timer.c       **** // define the maximum of callback functions (max is 8)
   7:timer.c       **** #define MAX_CALLBACKS   2
   8:timer.c       **** 
   9:timer.c       **** // Prescaler: valid values are: 1, 8, 64, 256, 1024
  10:timer.c       **** // change this also where the timer is enabled
  11:timer.c       **** #define PRESCALER	256
  12:timer.c       **** 
  13:timer.c       **** #ifndef F_CPU
  14:timer.c       **** #	error "ERROR: F_CPU not defined"
  15:timer.c       **** #endif
  16:timer.c       **** 
  17:timer.c       **** // The frequency in ms 
  18:timer.c       **** //#define TIMER_RES	(( PRESCALER * 2 * 256 / F_CPU * 1000 ))
  19:timer.c       **** #define TIMER_RES	4.096F
  20:timer.c       **** 
  21:timer.c       **** typedef struct _TIMER {
  22:timer.c       **** 	uint8_t cycles;
  23:timer.c       **** 	uint8_t counter;
  24:timer.c       **** 	void (*func)(void);
  25:timer.c       **** } TIMER;
  26:timer.c       **** 
  27:timer.c       **** /**
  28:timer.c       ****  * Here are the notifications saved if a callback function should be
  29:timer.c       ****  * triggered.
  30:timer.c       ****  */
  31:timer.c       **** static volatile uint8_t notify = 0x00;
  32:timer.c       **** 
  33:timer.c       **** /**
  34:timer.c       ****  * Holds all informations of the registered timers
  35:timer.c       ****  */
  36:timer.c       **** static volatile TIMER tlist[MAX_CALLBACKS];
  37:timer.c       **** 
  38:timer.c       **** /**
  39:timer.c       ****  * The ticks since startup
  40:timer.c       ****  */
  41:timer.c       **** static volatile uint32_t ticks = 0;
  42:timer.c       **** 
  43:timer.c       **** 
  44:timer.c       **** /**
  45:timer.c       ****  * ISR of Timer 0 is called every TIMER_RES ms.
  46:timer.c       ****  */
  47:timer.c       **** ISR(TIMER0_OVF_vect) {
 110               	.LM0:
 111               	.LFBB1:
 112 0000 1F92      		push r1
 113 0002 0F92      		push r0
 114 0004 0FB6      		in r0,__SREG__
 115 0006 0F92      		push r0
 116 0008 1124      		clr __zero_reg__
 117 000a 8F93      		push r24
 118 000c 9F93      		push r25
 119 000e AF93      		push r26
 120 0010 BF93      		push r27
 121               	/* prologue: Signal */
 122               	/* frame size = 0 */
 123               	/* stack size = 7 */
 124               	.L__stack_usage = 7
  48:timer.c       **** 
  49:timer.c       **** 	uint8_t i;
  50:timer.c       **** 
  51:timer.c       **** 	ticks++;
 126               	.LM1:
 127 0012 8091 0000 		lds r24,ticks
 128 0016 9091 0000 		lds r25,ticks+1
 129 001a A091 0000 		lds r26,ticks+2
 130 001e B091 0000 		lds r27,ticks+3
 131 0022 0196      		adiw r24,1
 132 0024 A11D      		adc r26,__zero_reg__
 133 0026 B11D      		adc r27,__zero_reg__
 134 0028 8093 0000 		sts ticks,r24
 135 002c 9093 0000 		sts ticks+1,r25
 136 0030 A093 0000 		sts ticks+2,r26
 137 0034 B093 0000 		sts ticks+3,r27
  52:timer.c       **** 
  53:timer.c       **** 	// set notifies
  54:timer.c       **** 	for (i = 0; i < MAX_CALLBACKS; i++) {
  55:timer.c       **** 		if (tlist[i].cycles > 0 && --tlist[i].counter == 0) {
 139               	.LM2:
 140 0038 8091 0000 		lds r24,tlist
 141 003c 8823      		tst r24
 142 003e 01F0      		breq .L3
 143 0040 8091 0000 		lds r24,tlist+1
 144 0044 8150      		subi r24,lo8(-(-1))
 145 0046 8093 0000 		sts tlist+1,r24
 146 004a 8111      		cpse r24,__zero_reg__
 147 004c 00C0      		rjmp .L3
  56:timer.c       **** 			notify |= (1 << (i+1));
 149               	.LM3:
 150 004e 8091 0000 		lds r24,notify
 151 0052 8260      		ori r24,lo8(2)
 152 0054 8093 0000 		sts notify,r24
  57:timer.c       **** 			tlist[i].counter = tlist[i].cycles;
 154               	.LM4:
 155 0058 8091 0000 		lds r24,tlist
 156 005c 8093 0000 		sts tlist+1,r24
 157               	.L3:
  55:timer.c       **** 		if (tlist[i].cycles > 0 && --tlist[i].counter == 0) {
 159               	.LM5:
 160 0060 8091 0000 		lds r24,tlist+4
 161 0064 8823      		tst r24
 162 0066 01F0      		breq .L1
 163 0068 8091 0000 		lds r24,tlist+5
 164 006c 8150      		subi r24,lo8(-(-1))
 165 006e 8093 0000 		sts tlist+5,r24
 166 0072 8111      		cpse r24,__zero_reg__
 167 0074 00C0      		rjmp .L1
  56:timer.c       **** 			notify |= (1 << (i+1));
 169               	.LM6:
 170 0076 8091 0000 		lds r24,notify
 171 007a 8460      		ori r24,lo8(4)
 172 007c 8093 0000 		sts notify,r24
 174               	.LM7:
 175 0080 8091 0000 		lds r24,tlist+4
 176 0084 8093 0000 		sts tlist+5,r24
 177               	.L1:
 178               	/* epilogue start */
  58:timer.c       **** 		}
  59:timer.c       **** 	}
  60:timer.c       **** }
 180               	.LM8:
 181 0088 BF91      		pop r27
 182 008a AF91      		pop r26
 183 008c 9F91      		pop r25
 184 008e 8F91      		pop r24
 185 0090 0F90      		pop r0
 186 0092 0FBE      		out __SREG__,r0
 187 0094 0F90      		pop r0
 188 0096 1F90      		pop r1
 189 0098 1895      		reti
 191               	.Lscope1:
 193               	.global	timer_init
 195               	timer_init:
  61:timer.c       **** 
  62:timer.c       **** /**
  63:timer.c       ****  * Initialize the timer.
  64:timer.c       ****  */
  65:timer.c       **** void timer_init(void) {
 197               	.LM9:
 198               	.LFBB2:
 199               	/* prologue: function */
 200               	/* frame size = 0 */
 201               	/* stack size = 0 */
 202               	.L__stack_usage = 0
  66:timer.c       **** 
  67:timer.c       **** 	uint8_t i;
  68:timer.c       **** 
  69:timer.c       **** 	for (i = 0; i < MAX_CALLBACKS; i++) {
  70:timer.c       **** 		tlist[i].func = NULL;
 204               	.LM10:
 205 009a 1092 0000 		sts tlist+2+1,__zero_reg__
 206 009e 1092 0000 		sts tlist+2,__zero_reg__
  71:timer.c       **** 		tlist[i].counter = 0;
 208               	.LM11:
 209 00a2 1092 0000 		sts tlist+1,__zero_reg__
  72:timer.c       **** 		tlist[i].cycles = 0;
 211               	.LM12:
 212 00a6 1092 0000 		sts tlist,__zero_reg__
  70:timer.c       **** 		tlist[i].func = NULL;
 214               	.LM13:
 215 00aa 1092 0000 		sts tlist+6+1,__zero_reg__
 216 00ae 1092 0000 		sts tlist+6,__zero_reg__
  71:timer.c       **** 		tlist[i].counter = 0;
 218               	.LM14:
 219 00b2 1092 0000 		sts tlist+5,__zero_reg__
 221               	.LM15:
 222 00b6 1092 0000 		sts tlist+4,__zero_reg__
  73:timer.c       **** 	}
  74:timer.c       **** 
  75:timer.c       **** 	// Timer 0, 8 bit timer
  76:timer.c       **** 	// Prescaler 256
  77:timer.c       **** 	TCCR0 = (1 << CS02);
 224               	.LM16:
 225 00ba 84E0      		ldi r24,lo8(4)
 226 00bc 83BF      		out 0x33,r24
  78:timer.c       **** 
  79:timer.c       **** 	// enable timer overflow on timer 0
  80:timer.c       **** 	TIMSK |= (1 << TOIE0); // enable overflow interrupt
 228               	.LM17:
 229 00be 89B7      		in r24,0x39
 230 00c0 8160      		ori r24,lo8(1)
 231 00c2 89BF      		out 0x39,r24
 232 00c4 0895      		ret
 234               	.Lscope2:
 236               	.global	timer_trigger_callbacks
 238               	timer_trigger_callbacks:
  81:timer.c       **** 
  82:timer.c       **** }
  83:timer.c       **** 
  84:timer.c       **** /**
  85:timer.c       ****  * Calls the outstanding callbackfunctions.
  86:timer.c       ****  *
  87:timer.c       ****  * This function has to be called as often as possible.
  88:timer.c       ****  */
  89:timer.c       **** void timer_trigger_callbacks(void) {
 240               	.LM18:
 241               	.LFBB3:
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 0 */
 245               	.L__stack_usage = 0
  90:timer.c       **** 
  91:timer.c       **** 	uint8_t i;
  92:timer.c       **** 	uint8_t sreg;
  93:timer.c       **** 
  94:timer.c       **** 	for (i = 0; i < MAX_CALLBACKS; i++) {
  95:timer.c       **** 		if (notify & (1 << (i+1)) && tlist[i].func != NULL) {
 247               	.LM19:
 248 00c6 8091 0000 		lds r24,notify
 249 00ca 81FF      		sbrs r24,1
 250 00cc 00C0      		rjmp .L11
 251 00ce 8091 0000 		lds r24,tlist+2
 252 00d2 9091 0000 		lds r25,tlist+2+1
 253 00d6 892B      		or r24,r25
 254 00d8 01F0      		breq .L11
  96:timer.c       **** 			tlist[i].func();
 256               	.LM20:
 257 00da E091 0000 		lds r30,tlist+2
 258 00de F091 0000 		lds r31,tlist+2+1
 259 00e2 0995      		icall
  97:timer.c       **** 			sreg = SREG;
 261               	.LM21:
 262 00e4 9FB7      		in r25,__SREG__
  98:timer.c       **** 			cli();
 264               	.LM22:
 265               	/* #APP */
 266               	 ;  98 "timer.c" 1
 267 00e6 F894      		cli
 268               	 ;  0 "" 2
  99:timer.c       **** 			notify &= ~(1 << (i+1));
 270               	.LM23:
 271               	/* #NOAPP */
 272 00e8 8091 0000 		lds r24,notify
 273 00ec 8D7F      		andi r24,lo8(-3)
 274 00ee 8093 0000 		sts notify,r24
 100:timer.c       **** 			SREG = sreg;
 276               	.LM24:
 277 00f2 9FBF      		out __SREG__,r25
 278               	.L11:
  95:timer.c       **** 		if (notify & (1 << (i+1)) && tlist[i].func != NULL) {
 280               	.LM25:
 281 00f4 8091 0000 		lds r24,notify
 282 00f8 82FF      		sbrs r24,2
 283 00fa 00C0      		rjmp .L10
  95:timer.c       **** 		if (notify & (1 << (i+1)) && tlist[i].func != NULL) {
 285               	.LM26:
 286 00fc 8091 0000 		lds r24,tlist+6
 287 0100 9091 0000 		lds r25,tlist+6+1
 288 0104 892B      		or r24,r25
 289 0106 01F0      		breq .L10
  96:timer.c       **** 			tlist[i].func();
 291               	.LM27:
 292 0108 E091 0000 		lds r30,tlist+6
 293 010c F091 0000 		lds r31,tlist+6+1
 294 0110 0995      		icall
  97:timer.c       **** 			sreg = SREG;
 296               	.LM28:
 297 0112 9FB7      		in r25,__SREG__
  98:timer.c       **** 			cli();
 299               	.LM29:
 300               	/* #APP */
 301               	 ;  98 "timer.c" 1
 302 0114 F894      		cli
 303               	 ;  0 "" 2
  99:timer.c       **** 			notify &= ~(1 << (i+1));
 305               	.LM30:
 306               	/* #NOAPP */
 307 0116 8091 0000 		lds r24,notify
 308 011a 8B7F      		andi r24,lo8(-5)
 309 011c 8093 0000 		sts notify,r24
 311               	.LM31:
 312 0120 9FBF      		out __SREG__,r25
 313               	.L10:
 314 0122 0895      		ret
 316               	.Lscope3:
 317               	.global	__floatunsisf
 318               	.global	__ltsf2
 319               	.global	__gtsf2
 320               	.global	__divsf3
 321               	.global	__fixunssfsi
 325               	.global	timer_register
 327               	timer_register:
 101:timer.c       **** 		}
 102:timer.c       **** 	}
 103:timer.c       **** }
 104:timer.c       **** 
 105:timer.c       **** /**
 106:timer.c       ****  * Register a timer.
 107:timer.c       ****  *
 108:timer.c       ****  * @param *fptr A function pointer for the callback function
 109:timer.c       ****  * @param time_ms The period in which the callback function should be triggered.
 110:timer.c       ****  *                The time has to be in range ITERATION_TIME <= x <= 255*ITERATION_TIME
 111:timer.c       ****  * @return Yields EXIT_SUCCESS if the function could be registered. Otherwise
 112:timer.c       ****  *                EXIT_FAILURE.
 113:timer.c       ****  */
 114:timer.c       **** uint8_t timer_register(void (*fptr)(void), uint16_t time_ms) {
 329               	.LM32:
 330               	.LFBB4:
 331 0124 CF92      		push r12
 332 0126 DF92      		push r13
 333 0128 EF92      		push r14
 334 012a FF92      		push r15
 335 012c 0F93      		push r16
 336 012e 1F93      		push r17
 337 0130 CF93      		push r28
 338 0132 DF93      		push r29
 339               	/* prologue: function */
 340               	/* frame size = 0 */
 341               	/* stack size = 8 */
 342               	.L__stack_usage = 8
 343 0134 8C01      		movw r16,r24
 115:timer.c       **** 
 116:timer.c       **** 	uint8_t i;
 117:timer.c       **** 	uint8_t cycles;
 118:timer.c       **** 
 119:timer.c       **** 	if (time_ms < TIMER_RES || time_ms > 255*TIMER_RES) {
 345               	.LM33:
 346 0136 80E0      		ldi r24,0
 347 0138 90E0      		ldi r25,0
 348 013a 0E94 0000 		call __floatunsisf
 349 013e 6B01      		movw r12,r22
 350 0140 7C01      		movw r14,r24
 351 0142 2FE6      		ldi r18,lo8(111)
 352 0144 32E1      		ldi r19,lo8(18)
 353 0146 43E8      		ldi r20,lo8(-125)
 354 0148 50E4      		ldi r21,lo8(64)
 355 014a 0E94 0000 		call __ltsf2
 356 014e 87FD      		sbrc r24,7
 357 0150 00C0      		rjmp .L31
 359               	.LM34:
 360 0152 2DE5      		ldi r18,lo8(93)
 361 0154 3FE8      		ldi r19,lo8(-113)
 362 0156 42E8      		ldi r20,lo8(-126)
 363 0158 54E4      		ldi r21,lo8(68)
 364 015a C701      		movw r24,r14
 365 015c B601      		movw r22,r12
 366 015e 0E94 0000 		call __gtsf2
 367 0162 1816      		cp __zero_reg__,r24
 368 0164 04F0      		brlt .L31
 120:timer.c       **** 		return EXIT_FAILURE;
 121:timer.c       **** 	}
 122:timer.c       **** 	cycles = (uint8_t)(time_ms/TIMER_RES);
 123:timer.c       **** 
 124:timer.c       **** 	for (i = 0; i < MAX_CALLBACKS; i++) {
 125:timer.c       **** 		if (tlist[i].func == NULL) {
 370               	.LM35:
 371 0166 8091 0000 		lds r24,tlist+2
 372 016a 9091 0000 		lds r25,tlist+2+1
 373 016e 892B      		or r24,r25
 374 0170 01F0      		breq .L30
 375 0172 8091 0000 		lds r24,tlist+6
 376 0176 9091 0000 		lds r25,tlist+6+1
 377 017a 892B      		or r24,r25
 378 017c 01F4      		brne .L31
 379 017e C1E0      		ldi r28,lo8(1)
 380 0180 D0E0      		ldi r29,0
 381 0182 00C0      		rjmp .L27
 382               	.L30:
 383 0184 C0E0      		ldi r28,0
 384 0186 D0E0      		ldi r29,0
 385               	.L27:
 122:timer.c       **** 	cycles = (uint8_t)(time_ms/TIMER_RES);
 387               	.LM36:
 388 0188 2FE6      		ldi r18,lo8(111)
 389 018a 32E1      		ldi r19,lo8(18)
 390 018c 43E8      		ldi r20,lo8(-125)
 391 018e 50E4      		ldi r21,lo8(64)
 392 0190 C701      		movw r24,r14
 393 0192 B601      		movw r22,r12
 394 0194 0E94 0000 		call __divsf3
 395 0198 0E94 0000 		call __fixunssfsi
 126:timer.c       **** 			tlist[i].func = fptr;
 397               	.LM37:
 398 019c CC0F      		lsl r28
 399 019e DD1F      		rol r29
 400 01a0 CC0F      		lsl r28
 401 01a2 DD1F      		rol r29
 402 01a4 C050      		subi r28,lo8(-(tlist))
 403 01a6 D040      		sbci r29,hi8(-(tlist))
 404 01a8 1B83      		std Y+3,r17
 405 01aa 0A83      		std Y+2,r16
 127:timer.c       **** 			tlist[i].counter = cycles;
 407               	.LM38:
 408 01ac 6983      		std Y+1,r22
 128:timer.c       **** 			tlist[i].cycles = cycles; // this at the end
 410               	.LM39:
 411 01ae 6883      		st Y,r22
 129:timer.c       **** 			return EXIT_SUCCESS;
 413               	.LM40:
 414 01b0 80E0      		ldi r24,0
 415 01b2 00C0      		rjmp .L26
 416               	.L31:
 120:timer.c       **** 		return EXIT_FAILURE;
 418               	.LM41:
 419 01b4 81E0      		ldi r24,lo8(1)
 420               	.L26:
 421               	/* epilogue start */
 130:timer.c       **** 		}
 131:timer.c       **** 	}
 132:timer.c       **** 
 133:timer.c       **** 	return EXIT_FAILURE;
 134:timer.c       **** }
 423               	.LM42:
 424 01b6 DF91      		pop r29
 425 01b8 CF91      		pop r28
 426 01ba 1F91      		pop r17
 427 01bc 0F91      		pop r16
 428 01be FF90      		pop r15
 429 01c0 EF90      		pop r14
 430 01c2 DF90      		pop r13
 431 01c4 CF90      		pop r12
 432 01c6 0895      		ret
 434               	.Lscope4:
 437               	.global	timer_deregister
 439               	timer_deregister:
 135:timer.c       **** 
 136:timer.c       **** /**
 137:timer.c       ****  * Remove a timer.
 138:timer.c       ****  *
 139:timer.c       ****  * @param The function pointer which were registered
 140:timer.c       ****  * @return EXIT_SUCCESS or EXIT_FAILURE
 141:timer.c       ****  */
 142:timer.c       **** uint8_t timer_deregister(void (*fptr)(void)) {
 441               	.LM43:
 442               	.LFBB5:
 443               	/* prologue: function */
 444               	/* frame size = 0 */
 445               	/* stack size = 0 */
 446               	.L__stack_usage = 0
 143:timer.c       **** 
 144:timer.c       **** 	uint8_t i, sreg;
 145:timer.c       **** 
 146:timer.c       **** 	for (i = 0; i < MAX_CALLBACKS; i++) {
 147:timer.c       **** 		if (tlist[i].func == fptr) {
 448               	.LM44:
 449 01c8 2091 0000 		lds r18,tlist+2
 450 01cc 3091 0000 		lds r19,tlist+2+1
 451 01d0 2817      		cp r18,r24
 452 01d2 3907      		cpc r19,r25
 453 01d4 01F0      		breq .L35
 454 01d6 2091 0000 		lds r18,tlist+6
 455 01da 3091 0000 		lds r19,tlist+6+1
 456 01de 2817      		cp r18,r24
 457 01e0 3907      		cpc r19,r25
 458 01e2 01F4      		brne .L36
 459 01e4 81E0      		ldi r24,lo8(1)
 460 01e6 90E0      		ldi r25,0
 461 01e8 00C0      		rjmp .L33
 462               	.L35:
 463 01ea 80E0      		ldi r24,0
 464 01ec 90E0      		ldi r25,0
 465               	.L33:
 148:timer.c       **** 			tlist[i].cycles = 0;
 467               	.LM45:
 468 01ee FC01      		movw r30,r24
 469 01f0 EE0F      		lsl r30
 470 01f2 FF1F      		rol r31
 471 01f4 EE0F      		lsl r30
 472 01f6 FF1F      		rol r31
 473 01f8 E050      		subi r30,lo8(-(tlist))
 474 01fa F040      		sbci r31,hi8(-(tlist))
 475 01fc 1082      		st Z,__zero_reg__
 149:timer.c       **** 			tlist[i].counter = 0;
 477               	.LM46:
 478 01fe 1182      		std Z+1,__zero_reg__
 150:timer.c       **** 			tlist[i].func = NULL;
 480               	.LM47:
 481 0200 1382      		std Z+3,__zero_reg__
 482 0202 1282      		std Z+2,__zero_reg__
 151:timer.c       **** 			sreg = SREG;
 484               	.LM48:
 485 0204 4FB7      		in r20,__SREG__
 152:timer.c       **** 			cli();
 487               	.LM49:
 488               	/* #APP */
 489               	 ;  152 "timer.c" 1
 490 0206 F894      		cli
 491               	 ;  0 "" 2
 153:timer.c       **** 			notify &= ~(1 << (i+1));
 493               	.LM50:
 494               	/* #NOAPP */
 495 0208 5091 0000 		lds r21,notify
 496 020c 9C01      		movw r18,r24
 497 020e 2F5F      		subi r18,-1
 498 0210 3F4F      		sbci r19,-1
 499 0212 81E0      		ldi r24,lo8(1)
 500 0214 90E0      		ldi r25,0
 501 0216 022E      		mov r0,r18
 502 0218 00C0      		rjmp 2f
 503               		1:
 504 021a 880F      		lsl r24
 505               		2:
 506 021c 0A94      		dec r0
 507 021e 02F4      		brpl 1b
 508 0220 8095      		com r24
 509 0222 8523      		and r24,r21
 510 0224 8093 0000 		sts notify,r24
 154:timer.c       **** 			SREG = sreg;
 512               	.LM51:
 513 0228 4FBF      		out __SREG__,r20
 155:timer.c       **** 			return EXIT_SUCCESS;
 515               	.LM52:
 516 022a 80E0      		ldi r24,0
 517 022c 0895      		ret
 518               	.L36:
 156:timer.c       **** 		}
 157:timer.c       **** 	}
 158:timer.c       **** 
 159:timer.c       **** 	return EXIT_FAILURE;
 520               	.LM53:
 521 022e 81E0      		ldi r24,lo8(1)
 160:timer.c       **** }
 523               	.LM54:
 524 0230 0895      		ret
 529               	.Lscope5:
 531               	.global	timer_get_ticks
 533               	timer_get_ticks:
 161:timer.c       **** 
 162:timer.c       **** /**
 163:timer.c       ****  * Get the ticks since power on.
 164:timer.c       ****  *
 165:timer.c       ****  * The timestamp gets incremented each TIMER_RES.
 166:timer.c       ****  *
 167:timer.c       ****  * @returns The timestamp
 168:timer.c       ****  */
 169:timer.c       **** uint32_t timer_get_ticks(void) {
 535               	.LM55:
 536               	.LFBB6:
 537               	/* prologue: function */
 538               	/* frame size = 0 */
 539               	/* stack size = 0 */
 540               	.L__stack_usage = 0
 170:timer.c       **** 	
 171:timer.c       **** 	uint8_t sreg = SREG;
 542               	.LM56:
 543 0232 2FB7      		in r18,__SREG__
 172:timer.c       **** 	uint32_t ret = 0;
 173:timer.c       **** 
 174:timer.c       **** 	cli();
 545               	.LM57:
 546               	/* #APP */
 547               	 ;  174 "timer.c" 1
 548 0234 F894      		cli
 549               	 ;  0 "" 2
 175:timer.c       **** 	ret = ticks;
 551               	.LM58:
 552               	/* #NOAPP */
 553 0236 6091 0000 		lds r22,ticks
 554 023a 7091 0000 		lds r23,ticks+1
 555 023e 8091 0000 		lds r24,ticks+2
 556 0242 9091 0000 		lds r25,ticks+3
 176:timer.c       **** 	SREG = sreg;
 558               	.LM59:
 559 0246 2FBF      		out __SREG__,r18
 177:timer.c       **** 
 178:timer.c       **** 	return ret;
 179:timer.c       **** }
 561               	.LM60:
 562 0248 0895      		ret
 568               	.Lscope6:
 569               	.global	__mulsf3
 571               	.global	timer_get_ms
 573               	timer_get_ms:
 180:timer.c       **** 
 181:timer.c       **** /**
 182:timer.c       ****  * Get the miliseconds since power on.
 183:timer.c       ****  *
 184:timer.c       ****  * @returns The time in ms.
 185:timer.c       ****  */
 186:timer.c       **** uint32_t timer_get_ms(void) {
 575               	.LM61:
 576               	.LFBB7:
 577               	/* prologue: function */
 578               	/* frame size = 0 */
 579               	/* stack size = 0 */
 580               	.L__stack_usage = 0
 187:timer.c       **** 
 188:timer.c       **** 	return timer_get_ticks() * TIMER_RES ;
 582               	.LM62:
 583 024a 0E94 0000 		call timer_get_ticks
 584 024e 0E94 0000 		call __floatunsisf
 585 0252 2FE6      		ldi r18,lo8(111)
 586 0254 32E1      		ldi r19,lo8(18)
 587 0256 43E8      		ldi r20,lo8(-125)
 588 0258 50E4      		ldi r21,lo8(64)
 589 025a 0E94 0000 		call __mulsf3
 590 025e 0E94 0000 		call __fixunssfsi
 189:timer.c       **** }
 592               	.LM63:
 593 0262 0895      		ret
 595               	.Lscope7:
 596               		.local	ticks
 597               		.comm	ticks,4,1
 598               		.local	tlist
 599               		.comm	tlist,8,1
 600               		.local	notify
 601               		.comm	notify,1,1
 606               	.Letext0:
 607               		.ident	"GCC: (GNU) 4.8.2"
 608               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:0000000000000000 timer.c
     /tmp/ccC1adV3.s:2      *ABS*:000000000000003e __SP_H__
     /tmp/ccC1adV3.s:3      *ABS*:000000000000003d __SP_L__
     /tmp/ccC1adV3.s:4      *ABS*:000000000000003f __SREG__
     /tmp/ccC1adV3.s:5      *ABS*:0000000000000000 __tmp_reg__
     /tmp/ccC1adV3.s:6      *ABS*:0000000000000001 __zero_reg__
     /tmp/ccC1adV3.s:108    .text:0000000000000000 __vector_11
                             .bss:0000000000000000 ticks
     /tmp/ccC1adV3.s:597    .bss:0000000000000004 tlist
     /tmp/ccC1adV3.s:599    .bss:000000000000000c notify
     /tmp/ccC1adV3.s:195    .text:000000000000009a timer_init
     /tmp/ccC1adV3.s:238    .text:00000000000000c6 timer_trigger_callbacks
     /tmp/ccC1adV3.s:327    .text:0000000000000124 timer_register
     /tmp/ccC1adV3.s:439    .text:00000000000001c8 timer_deregister
     /tmp/ccC1adV3.s:533    .text:0000000000000232 timer_get_ticks
     /tmp/ccC1adV3.s:573    .text:000000000000024a timer_get_ms

UNDEFINED SYMBOLS
__floatunsisf
__ltsf2
__gtsf2
__divsf3
__fixunssfsi
__mulsf3
__do_clear_bss
