using namespace std;
#include "Plans/Calibration/RotateOnce.h"

/*PROTECTED REGION ID(inccpp1467397900274) ENABLED START*/ //Add additional includes here
#include<MSLWorldModel.h>
#include <Game.h>
#include <RawSensorData.h>
#include <math.h>
#include <boost/lexical_cast.hpp>
/*PROTECTED REGION END*/
namespace alica
{
    /*PROTECTED REGION ID(staticVars1467397900274) ENABLED START*/ //initialise static variables here
    /*PROTECTED REGION END*/
    RotateOnce::RotateOnce() :
            DomainBehaviour("RotateOnce")
    {
        /*PROTECTED REGION ID(con1467397900274) ENABLED START*/ //Add additional options here
        /*PROTECTED REGION END*/
    }
    RotateOnce::~RotateOnce()
    {
        /*PROTECTED REGION ID(dcon1467397900274) ENABLED START*/ //Add additional options here
        /*PROTECTED REGION END*/
    }
    void RotateOnce::run(void* msg)
    {
        /*PROTECTED REGION ID(run1467397900274) ENABLED START*/ //Add additional options here
        msl_actuator_msgs::MotionControl mc;
        mc.motion.rotation = 0.1;
        send(mc);
        int currentSegment = getCurrentRotationSegment();
        double currentBearing = wm->rawSensorData->getAverageBearing();
        cout << "segment " << currentSegment << ", bearing " << currentBearing << endl;
        visitedSegments[currentSegment] = true;

        if (visitedSegments[0] && visitedSegments[1] && visitedSegments[2]
                && abs(circularDiff(currentBearing, initialBearing)) < 0.02)
        {
			double endAngle = wm->rawOdometry->position.angle;
			cout << "end angle: " << endAngle;
			alicaAutogenerated::lastRotationCalibError = circularDiff(initialAngle, endAngle);

			SystemConfig* sc = supplementary::SystemConfig::getInstance();
			Configuration *motion = (*sc)["Motion"];
			Configuration *processManaging = (*sc)["ProcessManaging"];

			int processId = processManaging->get<int>("Processes","ProcessDescriptions","Motion","id",NULL);

			int currentRadius = motion->get<int>("Motion","MotionControl","RobotRadius",NULL);

            if(alicaAutogenerated::lastRotationCalibError > alicaAutogenerated::CALIB_ERROR_THRESHOLD)
            {
            	// rotated too far => increase robot radius
            	motion->set(boost::lexical_cast<string>(currentRadius+1),"Motion.MotionControl.RobotRadius",NULL);
            }
            else if(alicaAutogenerated::lastRotationCalibError < -alicaAutogenerated::CALIB_ERROR_THRESHOLD)
            {
            	// rotated not far enough => decrease robot radius
            	motion->set(boost::lexical_cast<string>(currentRadius-1),"Motion.MotionControl.RobotRadius",NULL);
            }

            this->setSuccess(true);
        }
        /*PROTECTED REGION END*/
    }
    void RotateOnce::initialiseParameters()
    {
        /*PROTECTED REGION ID(initialiseParameters1467397900274) ENABLED START*/ //Add additional options here
        initialBearing = wm->rawSensorData->getAverageBearing();
        initialAngle = wm->rawOdometry->position.angle;
        //robotRadius = wm->
        segments[0] = initialBearing;
        segments[1] = fmod(segments[0] + 2.0 / 3 * M_PI + M_PI, (2 * M_PI)) - M_PI;
        segments[2] = fmod(segments[0] + 4.0 / 3 * M_PI + M_PI, (2 * M_PI)) - M_PI;
        visitedSegments[2] = visitedSegments[1] = visitedSegments[0] = false;
        cout << "starting angle: " << initialAngle;
        /*PROTECTED REGION END*/
    }
    /*PROTECTED REGION ID(methods1467397900274) ENABLED START*/ //Add additional methods here
    int RotateOnce::getCurrentRotationSegment()
    {
        double currentBearing = wm->rawSensorData->getAverageBearing();
        double minDiff = 10; // anything greater than 2 pi actually
        int segment = -1;
        for (int i = 0; i < 3; i++)
        {
            double diff = circularDiff(segments[i], currentBearing);
            if (diff < minDiff)
            {
                segment = i;
                minDiff = diff;
            }
        }
        return segment;
    }

    double RotateOnce::circularDiff(double a, double b)
    {
    	double diff = a - b;
    	double sign = diff / abs(diff);
    	double absDiff = abs(diff);
    	double atMost180 = min(2*M_PI - absDiff, absDiff);
    	return atMost180 * sign;
    }
/*PROTECTED REGION END*/
} /* namespace alica */
