#include "Plans/Standards/Own/ThrowIn/constraints/ThrowInOwnHalf1462360503828Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1462360503828) ENABLED START*/
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "engine/constraintmodul/SolverTerm.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
#include "MSLWorldModel.h"
#include "engine/RunningPlan.h"
#include "engine/Assignment.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:ThrowInOwnHalf

    /*		
     * Tasks: 
     * - EP:1462360503830 : ExecuteStandard (1439997010902)
     * - EP:1462360607517 : ReceiveStandard (1439997023446)
     * - EP:1462360610006 : AlternativeReceive (1462360858945)
     * - EP:1462360612527 : Block (1461237765109)
     *
     * States:
     * - Align (1462360503829)
     * - GrabBall (1462360912906)
     * - Pass (1462360919387)
     * - Wait (1462360928236)
     * - AlignReceive (1462361351034)
     * - Align (1462361358155)
     * - Block (1462361373364)
     * - ReceiveAlternative (1462363134771)
     * - Success (1462363320340)
     * - Receive (1462368095616)
     * - Successalternative (1462368161988)
     *
     * Vars:
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString): 
     * Static Variables: []
     * Domain Variables:

     * forall agents in Block let v = [x, y] 

     * forall agents in ReceiveStandard let v = [x, y] 

     */
    void Constraint1462361418213::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1462361418213) ENABLED START*/
        msl::MSLWorldModel* wm = msl::MSLWorldModel::get();
        auto constraint = autodiff::LTConstraint::TRUE;
        auto util = autodiff::TermBuilder::constant(0);
        auto domainVariables = c->getDomainVars();

        vector < shared_ptr < TVec >> poses;
        vector < shared_ptr < TVec >> blocker;
        vector < shared_ptr < TVec >> receiver;

        vector < shared_ptr < geometry::CNPosition >> robotPositions;

        for (int quantorCount = 0; quantorCount < domainVariables->size(); quantorCount++)
        {
            for (int i = 0; i < domainVariables->at(quantorCount)->size(); i++)
            {
                c->getDomainRanges()->at(quantorCount).at(i).at(0).at(0) = -wm->field->getFieldLength() / 2;
                c->getDomainRanges()->at(quantorCount).at(i).at(0).at(1) = wm->field->getFieldLength() / 2;
                c->getDomainRanges()->at(quantorCount).at(i).at(1).at(0) = -wm->field->getFieldWidth() / 2;
                c->getDomainRanges()->at(quantorCount).at(i).at(1).at(1) = wm->field->getFieldWidth() / 2;
                robotPositions.push_back(
                        wm->robots->teammates.getTeamMatePosition(c->getAgentsInScope()->at(quantorCount)->at(i)));
                auto vec = make_shared < TVec
                        > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
                                                                       > (domainVariables->at(quantorCount)->at(i)->at(
                                                                               0)),
                                                               dynamic_pointer_cast < autodiff::Variable
                                                                       > (domainVariables->at(quantorCount)->at(i)->at(
                                                                               1))});
                poses.push_back(vec);

                if (quantorCount == 0) // blocker
                {
                    blocker.push_back(vec);
                }
                else if (quantorCount == 1) // receiver
                {
                    receiver.push_back(vec);
                }
            }
        }

        shared_ptr < geometry::CNPoint2D > ballPose = wm->ball->getAlloBallPosition();
        if (ballPose == nullptr)
        {
            auto executerList = rp->getAssignment()->getRobotsWorkingAndFinished(1462360503830);
            cout << "ThrowInOwnHalf: Executer ID: " << executerList->front() << endl;
            ballPose = wm->robots->teammates.getTeamMatePosition(executerList->front())->getPoint();
        }

        shared_ptr < TVec > tvecBallPose = make_shared < TVec > (initializer_list<double> {ballPose->x, ballPose->y});
        auto ownGoalPos = wm->field->posOwnGoalMid();
        shared_ptr < TVec > ownGoalVec = make_shared < TVec > (initializer_list<double> {ownGoalPos->x, ownGoalPos->y});
        constraint = constraint & msl::MSLConstraintBuilder::applyRules(-1, poses);

        //Just for the case when we use this after "start" has been pressed
        if (wm->game->getSituation() == msl::Situation::Start)
        {
            constraint = constraint
                    & msl::MSLConstraintBuilder::ownPenaltyAreaDistanceExceptionRule(tvecBallPose, poses);
        }

        auto opps = wm->robots->opponents.getOpponentsAlloClustered();

        // determine the block position for our blocker (there can only be 0 or 1 blocker)
        if (blocker.size() > 0)
        {

            shared_ptr < geometry::CNPoint2D > nearestOpp = nullptr;
            double distBall2NearestOpp = 999999999.0;
            if (opps != nullptr)
            {
                for (auto opp : *opps)
                {
                    //is nearest to the ball?
                    opp = wm->field->mapOutOfOwnPenalty(opp, ballPose - opp);
                    double curDistBall2Opp = opp->distanceTo(ballPose);
                    if (curDistBall2Opp < distBall2NearestOpp)
                    {
                        nearestOpp = opp;
                        distBall2NearestOpp = curDistBall2Opp;
                    }
                }
                shared_ptr < TVec > blockedOpp = make_shared < TVec > (initializer_list<double> {nearestOpp->x,
                                                                                                 nearestOpp->y});
                auto dist2Opp = ConstraintBuilder::distanceSqr(blocker.at(0), blockedOpp);
                constraint = constraint & (dist2Opp > autodiff::TermBuilder::constant(650 * 650));
            }
        }

        // determine the receiving position for our receiver (there must be 1 receiver)
        if (receiver.size() > 0)
        {
            double yCordOfReceiver = wm->field->getFieldWidth() / 2.0;
            if (ballPose->x < 0.0) // right side line
            {
                // place the receiver 1m outside the sideline
                yCordOfReceiver -= 1000.0;
            }
            else // left side line
            {
                // place the receiver 1m outside the sideline
                yCordOfReceiver += 1000.0;
            }

            /* TODO
             * 1. Restrict receivers x and y coordinate to something in an allowed area
             * 2. Guarentee that the receivers pos is in front of any opponent close by
             */
            //constraint = constraint & (dist2Opp > autodiff::TermBuilder::constant(650 * 650));
        }

        //lazy utility
        vector < shared_ptr < TVec >> realRobotPosesTVec;
        for (int i = 0; i < robotPositions.size(); i++)
        {
            auto pos = robotPositions.at(i);
            if (pos != nullptr)
                realRobotPosesTVec.push_back(make_shared < TVec > (initializer_list<double> {pos->x, pos->y}));
            else
                realRobotPosesTVec.push_back(nullptr);
        }
        util = util + msl::MSLConstraintBuilder::lazyUtil(realRobotPosesTVec, poses);

        c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
        c->setUtility(dynamic_pointer_cast < alica::SolverTerm > (util));
        /*PROTECTED REGION END*/
    }

// State: Align

// State: Align

// State: GrabBall

// State: GrabBall

// State: Pass

// State: Pass

// State: Wait

// State: Wait

// State: AlignReceive

// State: AlignReceive

// State: Align

// State: Align

// State: Block

// State: Block

// State: ReceiveAlternative

// State: ReceiveAlternative

// State: Success

// State: Success

// State: Receive

// State: Receive

// State: Successalternative

// State: Successalternative

}
