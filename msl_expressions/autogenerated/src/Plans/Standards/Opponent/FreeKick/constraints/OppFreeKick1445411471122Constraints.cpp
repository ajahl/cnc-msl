#include "Plans/Standards/Opponent/FreeKick/constraints/OppFreeKick1445411471122Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1445411471122) ENABLED START*/
//Add additional using directives here
#include <memory>
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "engine/constraintmodul/SolverTerm.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
#include "MSLWorldModel.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:OppFreeKick

    /*		
     * Tasks: 
     * - EP:1445411471124 : Defend (1225115406909)
     * - EP:1454663032454 : Blocker (1432209050494)
     * - EP:1454663045348 : Attack (1222613952469)
     *
     * States:
     * - PosDefDefender (1445411471123)
     * - Success (1447875657650)
     * - PosDefBlocker (1454663055945)
     * - PosDefAttacker (1454663058990)
     *
     * Vars:
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString): 
     * Static Variables: []
     * Domain Variables:

     * forall agents in PosDefBlocker let v = [x, y] 

     * forall agents in PosDefDefender let v = [x, y] 

     * forall agents in PosDefAttacker let v = [x, y] 

     */
    void Constraint1445442215438::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1445442215438) ENABLED START*/

        // START INITILIZE VARIABLE CONTAINER
        auto constraint = autodiff::LTConstraint::TRUE;
        auto util = autodiff::TermBuilder::constant(0);


        auto domainVariables = c->getDomainVars();

        vector < shared_ptr < TVec >> poses;

        vector < shared_ptr < TVec >> defender;
        vector < shared_ptr < TVec >> blocker;
        vector < shared_ptr < TVec >> attacker;

        vector < shared_ptr < geometry::CNPosition >> robotPositions;

        for(int i = 0; i < domainVariables->at(0)->size(); i++) {
			c->getDomainRanges()->at(0).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(0).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(0).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
			c->getDomainRanges()->at(0).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
			robotPositions.push_back(wm->robots.getTeamMatePosition(c->getAgentsInScope()->at(0)->at(i)));
			auto vec = make_shared < TVec
			                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
			                                                                   > (domainVariables->at(0)->at(i)->at(0)),
			                                                           dynamic_pointer_cast < autodiff::Variable
			                                                                   > (domainVariables->at(0)->at(i)->at(1))});
			poses.push_back(vec);
			blocker.push_back(vec);
        }
        for(int i = 0; i < domainVariables->at(1)->size(); i++) {
			c->getDomainRanges()->at(1).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(1).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(1).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
			c->getDomainRanges()->at(1).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
			robotPositions.push_back(wm->robots.getTeamMatePosition(c->getAgentsInScope()->at(1)->at(i)));
			auto vec = make_shared < TVec
			                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
			                                                                   > (domainVariables->at(1)->at(i)->at(0)),
			                                                           dynamic_pointer_cast < autodiff::Variable
			                                                                   > (domainVariables->at(1)->at(i)->at(1))});
			poses.push_back(vec);
			defender.push_back(vec);
        }
        for(int i = 0; i < domainVariables->at(2)->size(); i++) {
			c->getDomainRanges()->at(2).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(2).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(2).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
			c->getDomainRanges()->at(2).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
			robotPositions.push_back(wm->robots.getTeamMatePosition(c->getAgentsInScope()->at(2)->at(i)));
			auto vec = make_shared < TVec
			                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
			                                                                   > (domainVariables->at(2)->at(i)->at(0)),
			                                                           dynamic_pointer_cast < autodiff::Variable
			                                                                   > (domainVariables->at(2)->at(i)->at(1))});
			poses.push_back(vec);
			attacker.push_back(vec);
        }
        cout << "OPFKC: poses, blocker, defender, attacker " << poses.size() << " " << blocker.size() << " " << defender.size() << " " << attacker.size() << endl;
        // END INITILIZE VARIABLE CONTAINER

        shared_ptr < geometry::CNPosition > mopsPose = wm->robots.getTeamMatePosition((*msl::MSLConstraintBuilder::sc)["Globals"]->get<double>("Globals.Team.mops.ID", NULL));
        if(mopsPose == nullptr) mopsPose = make_shared<geometry::CNPosition >(msl::MSLFootballField::posOwnGoalMid()->x, msl::MSLFootballField::posOwnGoalMid()->y ,0);
        shared_ptr < geometry::CNPoint2D > ballPose = wm->ball.getAlloBallPosition();
        double triWidht = wm->ball.getBallDiameter()
                + (*msl::MSLConstraintBuilder::sc)["MSLConstraintBuilder"]->get<double>(
                        "MSLConstraintBuilder.Tolerances.ballThreshhold", NULL);

        if (ballPose != nullptr)
        {
            shared_ptr < TVec > tvecBallPose = make_shared < TVec > (initializer_list<double> {ballPose->x, ballPose->y});
//            if(blocker.size() > 0) util = util + msl::MSLConstraintBuilder::approachUtil(tvecBallPose, blocker);
        }

        if (mopsPose != nullptr && ballPose != nullptr)
        {
            shared_ptr < geometry::CNPoint2D > vecToBall = (ballPose - mopsPose);
            shared_ptr < geometry::CNPoint2D > norm = vecToBall->rotate(M_PI / 2)->normalize();
            shared_ptr < geometry::CNPoint2D > poseB = ballPose -  (norm * triWidht);
            shared_ptr < geometry::CNPoint2D > poseC = ballPose +  (norm * triWidht);
            shared_ptr < geometry::CNPoint2D > blockerBall = ballPose - (vecToBall->normalize() * 3500);

            shared_ptr < TVec > tvecA = make_shared < TVec > (initializer_list<double> {mopsPose->x, mopsPose->y});
            shared_ptr < TVec > tvecB = make_shared < TVec > (initializer_list<double> {poseB->x, poseB->y});
            shared_ptr < TVec > tvecC = make_shared < TVec > (initializer_list<double> {poseC->x, poseC->y});
            shared_ptr < TVec > blockerBallTVec = make_shared < TVec > (initializer_list<double> {blockerBall->x, blockerBall->y});

//            constraint = constraint & msl::MSLConstraintBuilder::outsideTriangle(tvecA, tvecB, tvecC, 500, poses);

           	util = util + msl::MSLConstraintBuilder::approachUtil(blockerBallTVec, poses);

        }

        if (mopsPose != nullptr)
        {
            shared_ptr < TVec > tvecMops = make_shared < TVec > (initializer_list<double> {mopsPose->x, mopsPose->y});
//            util = util + msl::MSLConstraintBuilder::approachUtil(tvecMops, defender);
        }

//        constraint = constraint & msl::MSLConstraintBuilder::applyRules(8, poses);

        //lazy utility
        vector < shared_ptr < TVec >> realRobotPosesTVec;
        for (int i = 0; i < robotPositions.size(); i++)
        {
            realRobotPosesTVec.push_back(make_shared < TVec > (initializer_list<double> {robotPositions.at(i)->x,
                                                                                         robotPositions.at(i)->y}));
        }
//        util = util + msl::MSLConstraintBuilder::lazyUtil(realRobotPosesTVec, poses);

        c->setDomainVars(domainVariables);
        c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
        c->setUtility(dynamic_pointer_cast < alica::SolverTerm > (util));

        /*PROTECTED REGION END*/
    }

// State: PosDefDefender

// State: PosDefDefender

// State: Success

// State: Success

// State: PosDefBlocker

// State: PosDefBlocker

// State: PosDefAttacker

// State: PosDefAttacker

}
