#include "Plans/Standards/Opponent/FreeKick/constraints/OppFreeKick1445411471122Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1445411471122) ENABLED START*/
//Add additional using directives here
#include <memory>
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "engine/constraintmodul/SolverTerm.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
#include "MSLWorldModel.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:OppFreeKick

    /*		
     * Tasks: 
     * - EP:1445411471124 : Defend (1225115406909)
     * - EP:1454663032454 : Blocker (1432209050494)
     * - EP:1454663045348 : Attack (1222613952469)
     *
     * States:
     * - PosDefDefender (1445411471123)
     * - Success (1447875657650)
     * - PosDefBlocker (1454663055945)
     * - PosDefAttacker (1454663058990)
     *
     * Vars:
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString): 
     * Static Variables: []
     * Domain Variables:

     * forall agents in PosDefBlocker let v = [x, y] 

     * forall agents in PosDefDefender let v = [x, y] 

     * forall agents in PosDefAttacker let v = [x, y] 

     */
    void Constraint1445442215438::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1445442215438) ENABLED START*/

        // START INITILIZE VARIABLE CONTAINER

    	msl::MSLWorldModel* wm = msl::MSLWorldModel::get();
        auto constraint = autodiff::LTConstraint::TRUE;
        auto util = autodiff::TermBuilder::constant(0);
        auto domainVariables = c->getDomainVars();

        vector<shared_ptr<TVec>> poses;

        vector<shared_ptr<TVec>> defender;
        vector<shared_ptr<TVec>> blocker;
        vector<shared_ptr<TVec>> attacker;

        vector<shared_ptr<geometry::CNPosition>> robotPositions;

        for (int i = 0; i < domainVariables->at(0)->size(); i++)
        {
            c->getDomainRanges()->at(0).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(0).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(0).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
            c->getDomainRanges()->at(0).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
            robotPositions.push_back(wm->robots.teammates.getTeamMatePosition(c->getAgentsInScope()->at(0)->at(i)));
            auto vec = make_shared < TVec
                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(0)->at(i)->at(0)),
                                                           dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(0)->at(i)->at(1))});
            poses.push_back(vec);
            blocker.push_back(vec);
        }
        for (int i = 0; i < domainVariables->at(1)->size(); i++)
        {
            c->getDomainRanges()->at(1).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(1).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(1).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
            c->getDomainRanges()->at(1).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
            robotPositions.push_back(wm->robots.teammates.getTeamMatePosition(c->getAgentsInScope()->at(1)->at(i)));
            auto vec = make_shared < TVec
                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(1)->at(i)->at(0)),
                                                           dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(1)->at(i)->at(1))});
            poses.push_back(vec);
            defender.push_back(vec);
        }
        for (int i = 0; i < domainVariables->at(2)->size(); i++)
        {
            c->getDomainRanges()->at(2).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(2).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(2).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
            c->getDomainRanges()->at(2).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
            robotPositions.push_back(wm->robots.teammates.getTeamMatePosition(c->getAgentsInScope()->at(2)->at(i)));
            auto vec = make_shared < TVec
                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(2)->at(i)->at(0)),
                                                           dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(2)->at(i)->at(1))});
            poses.push_back(vec);
            attacker.push_back(vec);
        }
        //cout << "OPFKC: poses, blocker, defender, attacker " << poses.size() << " " << blocker.size() << " "
         //       << defender.size() << " " << attacker.size() << endl;
        // END INITILIZE VARIABLE CONTAINER

        shared_ptr <geometry::CNPoint2D> ballPose = wm->ball.getAlloBallPosition();
        if(ballPose == nullptr) {
        	ballPose = make_shared<geometry::CNPoint2D>(0,0);
        }
        shared_ptr<TVec> tvecBallPose = make_shared <TVec>(initializer_list<double> {ballPose->x, ballPose->y});
        auto ownGoalPos = msl::MSLFootballField::posOwnGoalMid();
        shared_ptr<TVec> ownGoalVec = make_shared <TVec>(initializer_list<double> {ownGoalPos->x, ownGoalPos->y});
        constraint = constraint & msl::MSLConstraintBuilder::applyRules(-1, poses);


        auto opps = wm->obstacles.getAlloObstaclePoints();

		vector<shared_ptr<TVec>> blockPositions;
		vector<shared_ptr<TVec>> blockOpponents;
		vector<shared_ptr<geometry::CNPoint2D>> blocktrackedOpponents;
		shared_ptr<geometry::CNPoint2D> nearestOpp = nullptr;
		//default nearest opp
		if(ballPose!=nullptr) nearestOpp = make_shared<geometry::CNPoint2D>(ballPose->x-250, ballPose->y);
		double dist = 999999999;
		for(auto opp : *opps) {
			//is nearest to the ball?
			if(ballPose!=nullptr) {
				msl::MSLFootballField::mapOutOfOwnPenalty(opp, ballPose-opp);
				double oDist = opp->distanceTo(ballPose);
				if(oDist < dist) {
					nearestOpp = opp;
					oDist = dist;
				}
			} else {
				opp = msl::MSLFootballField::mapOutOfOwnPenalty(opp);
			}

			//add blocking position
			shared_ptr<geometry::CNPoint2D> blockingPos;
			if (ballPose!=nullptr) {
				blockingPos = opp + (ballPose - opp)->normalize()*700;
			} else {
				blockingPos = make_shared<geometry::CNPoint2D>(opp->x-700,opp->y);
			}
			//only add if opp is in close to midline
			if (blockingPos->x < msl::MSLFootballField::FieldLength/6.0 && ballPose->distanceTo(blockingPos) > 1100) {
				blockPositions.push_back(make_shared <TVec>(initializer_list<double> {blockingPos->x, blockingPos->y}));
				blockOpponents.push_back(make_shared <TVec>(initializer_list<double> {opp->x, opp->y}));
				blocktrackedOpponents.push_back(opp);
			}
		}


		//attacker aka ball watcher
		if(attacker.size()>0) {
			if(ballPose!=nullptr && nearestOpp!=nullptr) {
				constraint = constraint & msl::MSLConstraintBuilder::spread(1200, attacker);
				//TODO constraint that ensures that we see the ball
				//constraint = constraint & MSLConstraintBuilder.SeeOppStdPass(nearestOpp.Pos, GeometryHelper.MAX_BALL_DETECTION_RADIUS, ball, wm, watchers, allOpponents.ToArray());
				auto utilattack = autodiff::TermBuilder::constant(0);
				auto ball2Goal = (ownGoalVec-tvecBallPose);
				for(int j=0; j<attacker.size(); j++) {
					auto relPos = ConstraintBuilder::inCoordsOf(attacker.at(j)-tvecBallPose, ball2Goal);
					constraint = constraint & (relPos->normalize()->getX() > autodiff::TermBuilder::constant(-1000));
					//Near Ball
					utilattack = utilattack + autodiff::TermBuilder::constant(100)*(1-(ConstraintBuilder::distanceSqr(attacker.at(j), tvecBallPose))/(msl::MSLFootballField::MaxDistanceSqr*attacker.size()));
					//Near own goal
					utilattack = utilattack + autodiff::TermBuilder::constant(10)*(autodiff::TermBuilder::constant(1)-(ConstraintBuilder::distanceSqr(attacker.at(j), ownGoalVec))/(msl::MSLFootballField::MaxDistanceSqr*attacker.size()));
				}
				util = util + utilattack;
				//c.UtilitySufficiencyThreshold = 0.98*(100+1+0.25);
			}
		}

		// Make a defenderwall between ball and goal, care other robots
		//TODO check Is this good close to the own goal???
		if(defender.size()>0) {
			auto direction = (ballPose - ownGoalPos)->normalize();
			auto wallPoint = direction*min(ownGoalPos->distanceTo(msl::MSLFootballField::posULOppPenaltyArea()), ballPose->distanceTo(ownGoalPos) / 2);
			wallPoint = wallPoint+ownGoalPos;
			constraint = constraint & msl::MSLConstraintBuilder::spread(1000, defender);
			auto directionTVec = make_shared <TVec>(initializer_list<double> {direction->x, direction->y});
			auto wallPointTVec = make_shared <TVec>(initializer_list<double> {wallPoint->x,wallPoint->y});
			for(int j=0; j<defender.size(); j++) {
				vector<shared_ptr<Term>> diffTerm;
				diffTerm.push_back(defender.at(j)->getX()-autodiff::TermBuilder::constant(wallPoint->x));
				diffTerm.push_back(defender.at(j)->getY()-autodiff::TermBuilder::constant(wallPoint->y));
				auto g2def = make_shared <TVec>(diffTerm);
				auto relPoint = ConstraintBuilder::inCoordsOf(g2def,directionTVec);
				constraint = constraint & ((shared_ptr<autodiff::Term>) make_shared<autodiff::Abs>(relPoint->getX()) < autodiff::TermBuilder::constant(200));
				util = util + autodiff::TermBuilder::constant(100)*( autodiff::TermBuilder::constant(1) - (ConstraintBuilder::distanceSqr(defender.at(j), wallPointTVec)/(msl::MSLFootballField::MaxDistanceSqr*defender.size())));
				for(int k=0; k<attacker.size(); k++) {
					constraint = constraint & ConstraintBuilder::distanceSqr(attacker.at(k),defender.at(j)) > autodiff::TermBuilder::constant(1000*1000);
				}
			}
			//c.Constraint &= ConstraintBuilder.Distance(defender[0],new AD.TVec(wallPoint.X,wallPoint.Y)) < 100;
		}

		if(blocker.size()>0) {
			int opponents2BlockCount = blockPositions.size();
			//c.Constraint &= MSLConstraintBuilder.See(bvec,10000,wm, blocker, new AD.TVec[] {});
			for(int k=0; k<blocker.size(); k++) {
				//close to block positions
				auto blockUtil = autodiff::TermBuilder::constant(0);
				for(int j=0; j<min(opponents2BlockCount, (int)blocker.size()); j++) {
					blockUtil = make_shared<autodiff::Max>(blockUtil, autodiff::TermBuilder::constant(10)*(autodiff::TermBuilder::constant(1)
							-(ConstraintBuilder::distanceSqr(blocker.at(k), blockPositions.at(j)))/autodiff::TermBuilder::constant(msl::MSLFootballField::MaxDistanceSqr*blocker.size())));
				}
				cout << blockUtil->toString() << endl;
				util = util + blockUtil;
/*
				//avoid opponents!
				for(int j=0; j<opponents2BlockCount; j++) {
					auto dist2Opp = ConstraintBuilder::distanceSqr(blocker.at(k),blockOpponents.at(j));
					constraint = constraint & (dist2Opp > autodiff::TermBuilder::constant(650*650)); //& (dist2Opp < 1500);
				}

				//avoid other blockers and prefere different block positions
				for(int j=k+1; j<blocker.size(); j++) {
					auto distBlockBlock = ConstraintBuilder::distanceSqr(blocker.at(k),blocker.at(j));
					constraint = constraint & distBlockBlock > autodiff::TermBuilder::constant(800*800);
					util = util + 5 * make_shared<autodiff::Min>(autodiff::TermBuilder::constant(2000*2000),distBlockBlock)
									/autodiff::TermBuilder::constant(2000*2000*blocker.size());
				}
				*/
			}
		}

        //lazy utility
        vector<shared_ptr<TVec>> realRobotPosesTVec;
        for (int i = 0; i < robotPositions.size(); i++)
        {
            realRobotPosesTVec.push_back(make_shared<TVec> (initializer_list<double> {robotPositions.at(i)->x,
                                                                                         robotPositions.at(i)->y}));
        }
        util = util + msl::MSLConstraintBuilder::lazyUtil(realRobotPosesTVec, poses);

        c->setDomainVars(domainVariables);
        c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
        c->setUtility(dynamic_pointer_cast < alica::SolverTerm > (util));
        /*PROTECTED REGION END*/
    }

// State: PosDefDefender

// State: PosDefDefender

// State: Success

// State: Success

// State: PosDefBlocker

// State: PosDefBlocker

// State: PosDefAttacker

// State: PosDefAttacker

}
