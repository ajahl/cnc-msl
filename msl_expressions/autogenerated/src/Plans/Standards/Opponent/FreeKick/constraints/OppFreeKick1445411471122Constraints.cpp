#include "Plans/Standards/Opponent/FreeKick/constraints/OppFreeKick1445411471122Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1445411471122) ENABLED START*/
//Add additional using directives here
#include <memory>
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "engine/constraintmodul/SolverTerm.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
#include "MSLWorldModel.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:OppFreeKick

    /*		
     * Tasks: 
     * - EP:1445411471124 : Defend (1225115406909)
     * - EP:1454663032454 : Blocker (1432209050494)
     * - EP:1454663045348 : Attack (1222613952469)
     *
     * States:
     * - PosDefDefender (1445411471123)
     * - Success (1447875657650)
     * - PosDefBlocker (1454663055945)
     * - PosDefAttacker (1454663058990)
     *
     * Vars:
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString): 
     * Static Variables: []
     * Domain Variables:

     * forall agents in PosDefBlocker let v = [x, y] 

     * forall agents in PosDefDefender let v = [x, y] 

     * forall agents in PosDefAttacker let v = [x, y] 

     */
    void Constraint1445442215438::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1445442215438) ENABLED START*/

        // START INITILIZE VARIABLE CONTAINER
        auto constraint = autodiff::LTConstraint::TRUE;
        auto util = autodiff::TermBuilder::constant(1);


        auto domainVariables = c->getDomainVars();

        vector < shared_ptr < TVec >> poses;

        vector < shared_ptr < TVec >> defender;
        vector < shared_ptr < TVec >> blocker;
        vector < shared_ptr < TVec >> attacker;

        vector < shared_ptr < geometry::CNPosition >> robotPositions;

        cout << "OPFKC: quantifiers " << c->getDomainRanges()->size() << endl;

        for (int i = 0; i < c->getDomainRanges()->at(0).size(); i++)
        {
            c->getDomainRanges()->at(0).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(0).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
            c->getDomainRanges()->at(0).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
            c->getDomainRanges()->at(0).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;

            robotPositions.push_back(wm->robots.getTeamMatePosition(c->getAgentsInScope()->at(0)->at(i)));
        }

        for (int i = 0; i < domainVariables->at(0)->size(); i++)
        {
            auto vec = make_shared < TVec
                    > (initializer_list<shared_ptr<Term>> {dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(0)->at(i)->at(0)),
                                                           dynamic_pointer_cast < autodiff::Variable
                                                                   > (domainVariables->at(0)->at(i)->at(1))});
            poses.push_back(vec);
            if (i == 0 || i == 1)
            {
                blocker.push_back(vec);
            }
            if (i == 2)
            {
                defender.push_back(vec);
            }
            if (i == 3)
            {
                attacker.push_back(vec);
            }

        }
        // END INITILIZE VARIABLE CONTAINER

//        shared_ptr < geometry::CNPosition > mopsPose = wm->robots.getTeamMatePosition((*msl::MSLConstraintBuilder::sc)["Globals"]->get<double>("Globals.Team.mops.ID", NULL));
        shared_ptr < geometry::CNPosition > mopsPose = make_shared < geometry::CNPosition > (-4000, 0, 0);
        shared_ptr < geometry::CNPoint2D > ballPose = wm->ball.getAlloBallPosition();
        double triWidht = wm->ball.getBallDiameter()
                + (*msl::MSLConstraintBuilder::sc)["MSLConstraintBuilder"]->get<double>(
                        "MSLConstraintBuilder.Tolerances.ballThreshhold", NULL);

        if (ballPose != nullptr)
        {
            shared_ptr < TVec > tvecBallPose = make_shared < TVec
                    > (initializer_list<double> {ballPose->x, ballPose->y});

            util = util + msl::MSLConstraintBuilder::approachUtil(tvecBallPose, blocker);
            constraint = constraint
                    & msl::MSLConstraintBuilder::outsideSphere(tvecBallPose, rules.getStayAwayRadiusOpp(), poses);

        }

        if (mopsPose != nullptr && ballPose != nullptr)
        {
            shared_ptr < geometry::CNPoint2D > vecToBall = (ballPose - mopsPose);
            shared_ptr < geometry::CNPoint2D > norm = vecToBall->rotate(M_PI / 2)->normalize();
            shared_ptr < geometry::CNPoint2D > poseB = (norm * triWidht) - vecToBall;
            shared_ptr < geometry::CNPoint2D > poseC = (norm * triWidht) + vecToBall;

            shared_ptr < TVec > tvecA = make_shared < TVec > (initializer_list<double> {mopsPose->x, mopsPose->y});
            shared_ptr < TVec > tvecB = make_shared < TVec > (initializer_list<double> {poseB->x, poseB->y});
            shared_ptr < TVec > tvecC = make_shared < TVec > (initializer_list<double> {poseC->x, poseC->y});

            constraint = constraint & msl::MSLConstraintBuilder::outsideTriangle(tvecA, tvecB, tvecC, 100, poses);
            constraint = constraint
                    & msl::MSLConstraintBuilder::insideCorridor(
                            make_shared < geometry::CNPoint2D > (mopsPose->x, mopsPose->y), ballPose, 2000, blocker);
        }

        if (mopsPose != nullptr)
        {
            shared_ptr < TVec > tvecMops = make_shared < TVec > (initializer_list<double> {mopsPose->x, mopsPose->y});

//        	util = util + msl::MSLConstraintBuilder::approachUtil(tvecMops, blocker);
            util = util + msl::MSLConstraintBuilder::approachUtil(tvecMops, defender);
        }

        constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OwnGoalArea, poses);
        constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OppGoalArea, poses);
        constraint = constraint & msl::MSLConstraintBuilder::spread(1000, poses);
        constraint = constraint & msl::MSLConstraintBuilder::insideArea(msl::Areas::OwnPenaltyArea, defender);

        constraint = constraint & msl::MSLConstraintBuilder::applyRules(8, poses);

        //lazy utility
        vector < shared_ptr < TVec >> realRobotPosesTVec;
        for (int i = 0; i < robotPositions.size(); i++)
        {
            realRobotPosesTVec.push_back(make_shared < TVec > (initializer_list<double> {robotPositions.at(i)->x,
                                                                                         robotPositions.at(i)->y}));
        }
        util = util + msl::MSLConstraintBuilder::lazyUtil(realRobotPosesTVec, poses);

        c->setDomainVars(domainVariables);
        c->setConstraint(dynamic_pointer_cast < alica::SolverTerm > (constraint));
        c->setUtility(dynamic_pointer_cast < alica::SolverTerm > (util));

        /*PROTECTED REGION END*/
    }

// State: PosDefDefender

// State: PosDefDefender

// State: Success

// State: Success

// State: PosDefBlocker

// State: PosDefBlocker

// State: PosDefAttacker

// State: PosDefAttacker

}
