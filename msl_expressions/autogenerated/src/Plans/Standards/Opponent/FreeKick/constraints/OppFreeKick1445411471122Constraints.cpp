#include "Plans/Standards/Opponent/FreeKick/constraints/OppFreeKick1445411471122Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1445411471122) ENABLED START*/
//Add additional using directives here
#include <memory>
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"
#include "MSLFootballField.h"
#include "engine/constraintmodul/SolverTerm.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
	//Plan:OppFreeKick

	/*
	 * Tasks:
	 * - EP:1445411471124 : DefaultTask (1225112227903)
	 *
	 * States:
	 * - PosDef (1445411471123)
	 * - Success (1447875657650)
	 *
	 * Vars:
	 */

	/*
	 * RuntimeCondition - (Name): NewRuntimeCondition
	 * (ConditionString):
	 * Static Variables: []
	 * Domain Variables:

	 * forall agents in PosDef let v = [x, y]

	 */
	void Constraint1445442215438::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
	{
		/*PROTECTED REGION ID(cc1445442215438) ENABLED START*/
		auto constraint = autodiff::LTConstraint::TRUE;
		auto util = autodiff::TermBuilder::constant(1);

		auto domainVariables = c->getDomainVars();
		vector<shared_ptr<TVec>> poses;

		auto mopsPose = wm->robots.getTeamMatePosition(
				(*msl::MSLConstraintBuilder::sc)["Globals"]->get<double>("Globals.Team.mops.ID", NULL));
		shared_ptr<geometry::CNPoint2D> ballPose = wm->ball.getAlloBallPosition();
		auto triWidht = wm->ball.getBallDiameter()
				+ (*msl::MSLConstraintBuilder::sc)["MSLConstraintBuilder"]->get<double>(
						"MSLConstraintBuilder.Tolerances.ballThreshhold", NULL);

		shared_ptr<geometry::CNPoint2D> vecToBall = nullptr;
		shared_ptr<geometry::CNPoint2D> poseB = nullptr;
		shared_ptr<geometry::CNPoint2D> poseC = nullptr;

		shared_ptr<TVec> tvecA = nullptr;
		shared_ptr<TVec> tvecB = nullptr;
		shared_ptr<TVec> tvecC = nullptr;
		shared_ptr<TVec> tvecBallPose = nullptr;

		if(ballPose != nullptr){
			tvecBallPose = make_shared<TVec>(initializer_list<double> {ballPose->x, ballPose->y});
		}

		if (mopsPose != nullptr && ballPose != nullptr)
		{

			vecToBall = (ballPose - mopsPose);
			poseB = ((vecToBall->rotate(M_PI / 2)->normalize() * triWidht) - vecToBall);
			poseC = ((vecToBall->rotate(M_PI / 2)->normalize() * triWidht) + vecToBall);

			tvecA = make_shared<TVec>(initializer_list<double> {mopsPose->x, mopsPose->y});
			tvecB = make_shared<TVec>(initializer_list<double> {poseB->x, poseB->y});
			tvecC = make_shared<TVec>(initializer_list<double> {poseC->x, poseC->y});
		}

		for (int i = 0; i < c->getDomainRanges()->at(0).size(); i++)
		{
			c->getDomainRanges()->at(0).at(i).at(0).at(0) = -msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(0).at(i).at(0).at(1) = msl::MSLFootballField::FieldLength / 2;
			c->getDomainRanges()->at(0).at(i).at(1).at(0) = -msl::MSLFootballField::FieldWidth / 2;
			c->getDomainRanges()->at(0).at(i).at(1).at(1) = msl::MSLFootballField::FieldWidth / 2;
		}

		for (int i = 0; i < domainVariables->at(0)->size(); i++)
		{
			poses.push_back(
					make_shared<TVec>(
							initializer_list<shared_ptr<Term>> {dynamic_pointer_cast<autodiff::Variable>(
									domainVariables->at(0)->at(i)->at(0)),
																dynamic_pointer_cast<autodiff::Variable>(
																		domainVariables->at(0)->at(i)->at(1))}));
		}

		if (tvecA != nullptr)
		{
			constraint = constraint & msl::MSLConstraintBuilder::outsideTriangle(tvecA, tvecB, tvecC, 100, poses);
		}
		constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OwnGoalArea, poses);
		constraint = constraint & msl::MSLConstraintBuilder::outsideArea(msl::Areas::OppGoalArea, poses);
		constraint = constraint & msl::MSLConstraintBuilder::applyRules(8, poses);

		if(tvecBallPose != nullptr) {
			constraint = constraint	& msl::MSLConstraintBuilder::outsideSphere(tvecBallPose, rules.getStayAwayRadiusOpp(), poses);
			util = util + msl::MSLConstraintBuilder::approachUtil(tvecBallPose, poses);
		}

		constraint = constraint & msl::MSLConstraintBuilder::spread(1000, poses);




		c->setDomainVars(domainVariables);
		c->setConstraint(dynamic_pointer_cast<alica::SolverTerm>(constraint));

		c->setUtility(dynamic_pointer_cast<alica::SolverTerm>(util));

//		cout << "Constraint: " << constraint->toString() << endl;
//		cout << "Util:       " << util->toString() << endl;

		/*PROTECTED REGION END*/
	}

// State: PosDef

// State: PosDef

// State: Success

// State: Success

}
