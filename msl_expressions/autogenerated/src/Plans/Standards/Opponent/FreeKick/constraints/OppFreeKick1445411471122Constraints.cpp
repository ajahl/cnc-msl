#include "Plans/Standards/Opponent/FreeKick/constraints/OppFreeKick1445411471122Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1445411471122) ENABLED START*/
//Add additional using directives here
#include <memory>
#include "Term.h"
#include "LTConstraint.h"
#include "MSLConstraintBuilder.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
    //Plan:OppFreeKick

    /*		
     * Tasks: 
     * - EP:1445411471124 : DefaultTask (1225112227903)
     *
     * States:
     * - PosDef (1445411471123)
     *
     * Vars:
     */

    /*
     * RuntimeCondition - (Name): NewRuntimeCondition
     * (ConditionString): 
     * Static Variables: []
     * Domain Variables:

     * forall agents in PosDef let v = [x, y] 

     */
    void Constraint1445442215438::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
    {
        /*PROTECTED REGION ID(cc1445442215438) ENABLED START*/
//    	shared_ptr<SolverTerm> constraint = c->getConstraint();
    	auto constraint = autodiff::LTConstraint::TRUE;
//
//    	auto domainVars = c->getDomainVars();
    	shared_ptr<vector<shared_ptr<vector<shared_ptr<vector<shared_ptr<SolverTerm>>>>>>> domainVariables = make_shared<vector<shared_ptr<vector<shared_ptr<vector<shared_ptr<SolverTerm>>>>>>>();
    	c->setDomainVars(domainVariables);
//
    	vector<shared_ptr<TVec>> poses;
//
    	for (int i = 0; i << domainVariables->at(0)->size(); i++)
    	{
//    		auto test = domainVars->at(0)->at(i);
    		vector<shared_ptr<Term>> vec;
//    		shared_ptr<Term> term1;
//    		term1.reset(&(static_cast<Term&>(*(test->at(0).get()))));
//    		shared_ptr<Term> term2;
//    		term2.reset(&(static_cast<Term&>(*(test->at(1).get()))));
//    		vec.push_back(term1);
//    		vec.push_back(term2);
    		shared_ptr<autodiff::Variable> x = make_shared<autodiff::Variable>();
    		shared_ptr<autodiff::Variable> y = make_shared<autodiff::Variable>();
    		vec.push_back(x);
    		vec.push_back(y);
    		poses.push_back(make_shared<TVec>(vec));
    		constraint = constraint & msl::MSLConstraintBuilder::insideArea(msl::Areas::OwnPenaltyArea, poses.at(i));
    	}
        /*PROTECTED REGION END*/
    }

// State: PosDef

// State: PosDef

}
