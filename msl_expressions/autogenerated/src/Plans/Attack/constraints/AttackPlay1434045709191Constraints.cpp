#include "Plans/Attack/constraints/AttackPlay1434045709191Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1434045709191) ENABLED START*/
//Add additional using directives here
#include "MSLFootballField.h"
#include "MSLWorldModel.h"
/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
	//Plan:AttackPlay

	/*
	 * Tasks:
	 * - EP:1434045709194 : Attack (1222613952469)
	 * - EP:1434045719840 : AttackSupport (1225115536468)
	 * - EP:1434045723977 : Defend (1225115406909)
	 * - EP:1434112675755 : InGamePassReceiver (1307185798142)
	 *
	 * States:
	 * - Attack (1434045709193)
	 * - MidFieldDefense (1434045868018)
	 * - Defend (1434045870617)
	 * - Release (1434112762535)
	 * - ApproachPass (1436536084172)
	 * - InterceptPass (1436536085953)
	 * - InterceptPass (1436536121614)
	 * - ApproachPass (1436536123918)
	 *
	 * Vars:
	 * - TargetX (1457002241973)
	 * - TargetY (1457002247256)
	 */

	/*
	 * RuntimeCondition - (Name): NewRuntimeCondition
	 * (ConditionString):
	 * Static Variables: [TargetX, TargetY]
	 * Domain Variables:

	 */
	void Constraint1434112519736::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
	{
		/*PROTECTED REGION ID(cc1434112519736) ENABLED START*/
//		msl::MSLFootballField* ff = FootballField::getInstance();
//		c->setStaticRanges() = MSLConstraintBuilder.RangeInsideArea(Areas.Field, 1);
//		c.StaticRanges[0, 0] += 2000;
//		c.StaticRanges[0, 1] -= ff.PenaltyAreaXSize * 1.25;
//		c.StaticRanges[1, 0] += 1200;
//		c.StaticRanges[1, 1] -= 1200;
//		WorldModel wm = WorldModel.Get();
//		SharedWorld swm = wm.SharedWorldModel;
//
//		ICollection<int> r1 = rp.Assignment.GetRobotsWorking(1397562063700);
//		AD.TVec
//		passer = null;
//		Position passerPos = null;
//		foreach(int id in r1)
//		{
//			passerPos = swm.GetRobotDataByID(id).PlayerPosition;
//			passer = new AD.TVec(passerPos.X,passerPos.Y);
//			break;
//		}
//		ICollection<int> r2 = rp.Assignment.GetRobotsWorking(1397562117846);
//		AD.TVec
//		receiver = null;
//		foreach(int id in r2)
//		{
//			Position p = swm.GetRobotDataByID(id).PlayerPosition;
//			receiver = new AD.TVec(p.X,p.Y);
//			break;
//		}
//		if (c.StaticVars == null)
//			return;
//		AD.TVec
//		target = new AD
//		.TVec(c.StaticVars[0],c.StaticVars[1]);
//
//		c.Constraint = ConstraintBuilder.Distance(target, receiver) < 5000;
//		if (passerPos.X <= 150)
//		{
//			c.Constraint &= target.X > passerPos.X + 1000;
//		}
//		else
//		{
//			c.Constraint &= target.X > 500;
//		}
//		c.Constraint &= MSLConstraintBuilder.OutsideArea(Areas.OppPenaltyArea, target);
//		c.Constraint &= MSLConstraintBuilder.OutsideArea(Areas.OwnPenaltyArea, target);
//		List < TrackedOpponent > opps = wm.GetTrackedOpponents();
//
//		AD.TVec
//		passVec = target - passer;
//		AD.Term
//		passLength = ConstraintBuilder.Distance(target, passer);
//		AD.TVec[] oppVecs = new AD.TVec[opps.Count];
//		AD.Term
//		minOppDist = 1000000;
//		for (int i = 0; i < opps.Count; i++)
//		{
//			oppVecs[i] = new AD
//			.TVec(opps[i].Pos.X,opps[i].Pos.Y);
//			c.Constraint &= ConstraintBuilder.Distance(target, oppVecs[i]) > 1500; //get away from opps
//			/*//free corridor:
//			 AD.TVec relOppVec = ConstraintBuilder.InCoordsOf(oppVecs[i]-passer,passVec);
//			 AD.Term absOppY = new AD.Abs(relOppVec.Y);
//			 AD.Term dist2Pass = absOppY * passLength;
//			 //c.Constraint &= relOppVec.X > 1 | relOppVec.X < 0 | dist2Pass > 800;
//			 c.Constraint &= ConstraintBuilder.IfThen((relOppVec.X <= 1 & relOppVec.X >= 0),
//			 (dist2Pass > 1000));*/
//			//oppUtil += AD.TermBuilder.Power(ConstraintBuilder.Distance(target,oppVecs[i]),0.5);
//			minOppDist = new AD
//		.Min(minOppDist,ConstraintBuilder.Distance(target,oppVecs[i]));
//
//	}
//	if (opps.Count == 0)
//	{
//		minOppDist = 0;
//	}
//
//	double targetDist = Math.Abs(passerPos.Y) + ff.FieldWidth * 0.5;
//	targetDist += 500;
//
//	c.Utility = 100000-( new AD.Abs( targetDist - ConstraintBuilder.Distance(target,passer))) + minOppDist;
/*PROTECTED REGION END*/
}

// State: Attack

// State: Attack

// State: MidFieldDefense

// State: MidFieldDefense

// State: Defend

// State: Defend

// State: Release

// State: Release

// State: ApproachPass

// State: ApproachPass

// State: InterceptPass

// State: InterceptPass

// State: InterceptPass

// State: InterceptPass

// State: ApproachPass

// State: ApproachPass

}
