#include "Plans/Attack/constraints/AttackPlay1434045709191Constraints.h"
using namespace std;
using namespace alica;
/*PROTECTED REGION ID(ch1434045709191) ENABLED START*/
//Add additional using directives here
#include "MSLFootballField.h"
#include "MSLWorldModel.h"
#include "engine/constraintmodul/ConstraintDescriptor.h"
#include "engine/RunningPlan.h"
#include "engine/Assignment.h"
#include "AutoDiff.h"
#include "MSLConstraintBuilder.h"

/*PROTECTED REGION END*/

namespace alicaAutogenerated
{
	//Plan:AttackPlay

	/*
	 * Tasks:
	 * - EP:1434045709194 : Attack (1222613952469)
	 * - EP:1434045719840 : AttackSupport (1225115536468)
	 * - EP:1434045723977 : Defend (1225115406909)
	 * - EP:1434112675755 : InGamePassReceiver (1307185798142)
	 *
	 * States:
	 * - Attack (1434045709193)
	 * - MidFieldDefense (1434045868018)
	 * - Defend (1434045870617)
	 * - Release (1434112762535)
	 * - ApproachPass (1436536084172)
	 * - InterceptPass (1436536085953)
	 * - InterceptPass (1436536121614)
	 * - ApproachPass (1436536123918)
	 *
	 * Vars:
	 * - TargetX (1457002241973)
	 * - TargetY (1457002247256)
	 */

	/*
	 * RuntimeCondition - (Name): NewRuntimeCondition
	 * (ConditionString):
	 * Static Variables: [TargetX, TargetY]
	 * Domain Variables:

	 */
	void Constraint1434112519736::getConstraint(shared_ptr<ConstraintDescriptor> c, shared_ptr<RunningPlan> rp)
	{
//		/*PROTECTED REGION ID(cc1434112519736) ENABLED START*/
//		msl::MSLWorldModel* wm = msl::MSLWorldModel::get();
//		msl::MSLFootballField* ff = msl::MSLFootballField::getInstance();
//		c->setStaticRanges(msl::MSLConstraintBuilder::RangeInsideArea(Areas.Field, 1));
//		c.StaticRanges[0, 0] += 2000;
//		c.StaticRanges[0, 1] -= ff->PenaltyAreaLength * 1.25;
//		c.StaticRanges[1, 0] += 1200;
//		c.StaticRanges[1, 1] -= 1200;
//		shared_ptr<vector<int>> r1 = rp->getAssignment()->getRobotsWorking(1434045709194);
//		shared_ptr<autodiff::TVec> passer = nullptr;
//		shared_ptr<geometry::CNPosition> passerPos = nullptr;
//		for (int id : *r1)
//		{
//			passerPos = wm->robots.teammates.getTeamMatePosition(id);
//			passer = make_shared<autodiff::TVec>(initializer_list<double> {passerPos->x, passerPos->y});
//			break;
//		}
//		shared_ptr<vector<int> > r2 = rp->getAssignment()->getRobotsWorking(1434112675755);
//		shared_ptr<autodiff::TVec> receiver = nullptr;
//		for (int id : *r2)
//		{
//			shared_ptr<geometry::CNPosition> p = wm->robots.teammates.getTeamMatePosition(id);
//			receiver = make_shared<autodiff::TVec>(initializer_list<double> {p->x, p->y});
//			break;
//		}
//		if (c->getStaticVars() == nullptr)
//		{
//			return;
//		}
//		shared_ptr<autodiff::TVec> target = autodiff::TVec(c->getStaticVars()->at(0),c->getStaticVars()->at(1));
//
//		c->setConstraint(ConstraintBuilder::distance(target, receiver) < 5000);
//		if (passerPos->x <= 150)
//		{
//			c->Constraint &= target->x > passerPos->x + 1000;
//		}
//		else
//		{
//			c->Constraint &= target.X > 500;
//		}
//		c->Constraint &= MSLConstraintBuilder.OutsideArea(Areas.OppPenaltyArea, target);
//		c->Constraint &= MSLConstraintBuilder.OutsideArea(Areas.OwnPenaltyArea, target);
//		List < TrackedOpponent > opps = wm->robots.opponents.GetTrackedOpponents();
//
//		shared_ptr<autodiff::TVec> passVec = target - passer;
//		autodiff::Term passLength = ConstraintBuilder.Distance(target, passer);
//		shared_ptr<autodiff::TVec>[] oppVecs = new AD.TVec[opps.Count];
//		autodiff::Term	minOppDist = 1000000;
//		for (int i = 0; i < opps.Count; i++)
//		{
//			oppVecs[i] = new AD
//			.TVec(opps[i].Pos.X,opps[i].Pos.Y);
//			c.Constraint &= ConstraintBuilder.Distance(target, oppVecs[i]) > 1500; //get away from opps
//			minOppDist = new AD
//		.Min(minOppDist,ConstraintBuilder.Distance(target,oppVecs[i]));
//
//	}
//	if (opps->size() == 0)
//	{
//		minOppDist = 0;
//	}
//
//	double targetDist = abs(passerPos->y) + ff->FieldWidth * 0.5;
//	targetDist += 500;
//
//	c.Utility = 100000-( new AD.Abs( targetDist - ConstraintBuilder.Distance(target,passer))) + minOppDist;
//		/*PROTECTED REGION END*/
	}

// State: Attack

// State: Attack

// State: MidFieldDefense

// State: MidFieldDefense

// State: Defend

// State: Defend

// State: Release

// State: Release

// State: ApproachPass

// State: ApproachPass

// State: InterceptPass

// State: InterceptPass

// State: InterceptPass

// State: InterceptPass

// State: ApproachPass

// State: ApproachPass

}
